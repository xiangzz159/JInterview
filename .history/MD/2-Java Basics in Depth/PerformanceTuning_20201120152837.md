- [JVM](#jvm)
  - [实现原理](#实现原理)
  - [JVM内存模型](#jvm内存模型)
  - [Java类文件结构](#java类文件结构)
  - [Java虚拟机类加载机制与类加载器](#java虚拟机类加载机制与类加载器)
    - [类加载方式](#类加载方式)
    - [类加载的动态性体现:](#类加载的动态性体现)
    - [类加载过程](#类加载过程)
  - [运行时数据区：深入理解堆/栈/元空间](#运行时数据区深入理解堆栈元空间)
    - [方法区](#方法区)
    - [堆内存](#堆内存)
    - [程序计数器](#程序计数器)
    - [虚拟机栈](#虚拟机栈)
    - [本地方法栈](#本地方法栈)
    - [元空间](#元空间)
  - [垃圾回收机制](#垃圾回收机制)
    - [CMS(Concurrent Mark Sweep)](#cmsconcurrent-mark-sweep)
    - [G1](#g1)
    - [ZGC](#zgc)
    - [Shenandoah](#shenandoah)
    - [Epsilon](#epsilon)
  - [Java字节码执行引擎](#java字节码执行引擎)
    - [栈帧（Stack Frame）](#栈帧stack-frame)
      - [1.局部变量表](#1局部变量表)
      - [2.操作数栈](#2操作数栈)
      - [3.动态链接](#3动态链接)
      - [4.方法返回地址](#4方法返回地址)
      - [5.附加信息](#5附加信息)
    - [方法调用](#方法调用)
      - [1.解析](#1解析)
      - [2.分派](#2分派)
      - [3.基于栈的字节码解释执行引擎](#3基于栈的字节码解释执行引擎)
  - [JDK性能监控于故障处理](#jdk性能监控于故障处理)
    - [jps](#jps)
    - [jmap](#jmap)
    - [jstat](#jstat)
    - [jinfo](#jinfo)
    - [jhat](#jhat)
    - [jstack](#jstack)
  - [JVM服务器实战调优](#jvm服务器实战调优)
    - [GCView](#gcview)
    - [Arthas](#arthas)
- [MySQL](#mysql)
  - [MySQL优化基础](#mysql优化基础)
  - [多版本并发控制MVCC](#多版本并发控制mvcc)
  - [应用程序性能剖析](#应用程序性能剖析)
  - [慢查询日志剖析](#慢查询日志剖析)
  - [数据库优化与索引](#数据库优化与索引)
  - [BTree索引/Hash索引/聚簇索引/非聚簇索引](#btree索引hash索引聚簇索引非聚簇索引)
  - [索引的选择和表的维护](#索引的选择和表的维护)
  - [深入索引原理解析](#深入索引原理解析)
  - [高效索引策略与SQL查询优化](#高效索引策略与sql查询优化)
  - [SQL优化查询器](#sql优化查询器)
- [Tomcat](#tomcat)
  - [Tomcat概述](#tomcat概述)
  - [Web引用通信机制](#web引用通信机制)
  - [Tomcat重要核心组件](#tomcat重要核心组件)
  - [Tomcat类加载器](#tomcat类加载器)
  - [Tomcat内部原理与线程模型](#tomcat内部原理与线程模型)
  - [HTTP协议和BIO/NIO](#http协议和bionio)
  - [Tomcat高可用集群架构方案](#tomcat高可用集群架构方案)
  - [Tomcat高可用集群架构实现](#tomcat高可用集群架构实现)
  - [Tomcat性能调用实战](#tomcat性能调用实战)


# JVM
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。

## 实现原理
1. jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。
2. java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码，通过特定平台运行。

![img](./img/1587882-20190308111205469-1550734334.png)

## JVM内存模型
JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)

![img](./img/1587882-20190308115822736-2106039872.png)

如图所示jvm内存划分为五部分
- 方法区（Method Area）  
  方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常。
- 堆区（Heap）  
  堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。
- 虚拟机栈（VM Stack）  
  虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。
- 本地方法栈（Native Method Stack）  
  本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。
- 程序计数器（Program Counter Register）  
  程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它，它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。

## Java类文件结构
Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。

Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。

Class文件格式只有两种数据类型：无符号数和表。

无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数；可用来描述数字，索引引用，数量值或者按照UTF-8编码构成的字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述由层次关系的复合结构的数据，整个Class文件本质上就是一张表。

![img](./img/940623-20170402225302461-264984043.png)

## Java虚拟机类加载机制与类加载器
Java源代码被编译为字节码文件后，需要加载进内存才能在程序中被使用。程序启动时并不会一次性加载程序要用的所有class文件，而是根据程序需要，通过Java的类加载机制（ClassLoader）动态加载某个class文件到内存当中。ClassLoader就是用来在运行时加载字节码文件进内存的，加载的过程是线程安全的。

> 如何保证类加载时线程安全：同步代码块synchronized+ConcurrentHashMap 用于映射类名+锁

### 类加载方式
1. 隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。 
2. 显式装载， 通过class.forname()等方法，显式加载需要的类

### 类加载的动态性体现:
一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现

### 类加载过程
1. 对字节码文件（class文件）进行加载
2. 连接，将原始的类定义信息转入JVM运行（分配内存）
    - 验证：JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。
    - 准备：创建类或者接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显示初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。
    - 解析：在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在 Java 虚拟机规范中，详细介绍了类，接口，方法和字段等各方面的解析。
3. 初始化，这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。
4. 类的使用
5. 类的卸载，执行垃圾回收，过期类被卸载


> [Java的ClassLoader机制](http://www.hollischuang.com/archives/199)

- Bootstrp loader  
  Bootstrp加载器是用C++语言写的，它是在Java虚拟机启动后初始化的，它主要负责加载%JAVA_HOME%/jre/lib,-Xbootclasspath参数指定的路径以及%JAVA_HOME%/jre/classes中的类。

- ExtClassLoader  
  Bootstrp loader加载ExtClassLoader,并且将ExtClassLoader的父加载器设置为Bootstrp loader.ExtClassLoader是用Java写的，具体来说就是 sun.misc.Launcher$ExtClassLoader，ExtClassLoader主要加载%JAVA_HOME%/jre/lib/ext，此路径下的所有classes目录以及java.ext.dirs系统变量指定的路径中类库。

- AppClassLoader  
  Bootstrp loader加载完ExtClassLoader后，就会加载AppClassLoader,并且将AppClassLoader的父加载器指定为 ExtClassLoader。AppClassLoader也是用Java写成的，它的实现类是 sun.misc.Launcher$AppClassLoader，另外我们知道ClassLoader中有个getSystemClassLoader方法,此方法返回的正是AppclassLoader.AppClassLoader主要负责加载classpath所指定的位置的类或者是jar文档，它也是Java程序默认的类加载器。

![img](./img/6752752-69487010ef6ab85a.png)

## 运行时数据区：深入理解堆/栈/元空间
Java虚拟机在运行时，会把内存空间分为若干个区域，根据《Java虚拟机规范（Java SE 7 版）》的规定，Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、程序计数器。

![img](./img/20180807233055376.png)

### 方法区
方法区主要用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据。在jdk1.7及其之前，方法区是堆的一个“逻辑部分”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。

从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中，（常量池除字符串常量池还有class常量池等），这里只是把字符串常量池移到堆内存中；在jdk1.8中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。根据网上的资料结合自己的理解对jdk1.3~1.6、jdk1.7、jdk1.8中方法区的变迁画了张图如下：

![img](./img/20180807233340374.png)

去永久代的原因有：
1. 字符串存在永久代中，容易出现性能问题和内存溢出。
2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

### 堆内存
堆内存主要用于存放对象和数组，它是JVM管理的内存中最大的一块区域，堆内存和方法区都被所有线程共享，在虚拟机启动时创建。在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为新生代（YoungGeneration）和老年代（OldGeneration），新生代还可以分为Eden、From Survivor、To Survivor。

### 程序计数器
程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间，此外，程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域。

### 虚拟机栈
虚拟机栈也是每个线程私有的一块内存空间，它描述的是方法的内存模型，直接看下图所示：
![img](./img/20180807233512975.png)

虚拟机会为每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。一个栈帧就对应Java代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个Java方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。

### 本地方法栈
本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是Java方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致，在HotSpot中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述。

### 元空间
上面说到，jdk1.8中，已经不存在永久代（方法区），替代它的一块空间叫做“元空间”，和永久代类似，都是JVM规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，但可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来指定元空间的大小。

## 垃圾回收机制
垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

基于可达性分析法的 GC 垃圾回收的效率较高，实现起来比较简单（引用计算法是是算法简单，实现较难），但是其缺点在于 GC 期间，整个应用需要被挂起（STW，Stop-the-world，下同），后面很多此类算法的提出，都是在解决这个问题（缩小 STW 时间）。

基于引用计数法的 GC，天然带有增量特性（incremental），GC 可与应用交替运行，不需要暂停应用；同时，在引用计数法中，每个对象始终都知道自己的被引用数，当计数器为0时，对象可以马上回收，而在可达性分析类 GC 中，即使对象变成了垃圾，程序也无法立刻感知，直到 GC 执行前，始终都会有一部分内存空间被垃圾占用。

上述两类 GC 各有千秋，真正的工业级实现一般是这两类算法的组合，但是总体来说，基于可达性分析的 GC 还是占据了主流，究其原因，首先，引用计数算法无法解决「循环引用无法回收」的问题，即两个对象互相引用，所以各对象的计数器的值都是 1，即使这些对象都成了垃圾（无外部引用），GC 也无法将它们回收。当然上面这一点还不是引用计数法最大的弊端，引用计数算法最大的问题在于：计数器值的增减处理非常繁重，譬如对根对象的引用，此外，多个线程之间共享对象时需要对计数器进行原子递增/递减，这本身又带来了一系列新的复杂性和问题，计数器对应用程序的整体运行速度的影响，这里的细节可以参考文章：Boost's shared_ptr up to 10× slower than OCaml's garbage collection。

### CMS(Concurrent Mark Sweep)
并发-标记-清除算法，针对老年代回收的GC

CMS以获取最小停顿时间为目的。

在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，CMS可以用于此场景。 

1. 初始标记(STW)：该阶段进行可达性分析，标记GC ROOT能直接关联到的对象。会暂停用户线程。
2. 并发标记：和用户线程并发执行，由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。
3. 并发预清理：标记从新生代晋升的对象、新分配到老年代的对象以及在并发阶段被修改了的对象。
    - 通过GC ROOT TRACING可到达确定老年代的对象是活着
    - 通过Minor GC扫描新生代
    - 通过CARD TABLE标记老年代
    - Minor GC通过扫描card table就可以很快的识别老年代引用新生代。
4. 重标记(STW)：暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。
5. 并发清理：用户线程被重新激活，同时清理那些无效的对象。
6. 重置：CMS清除内部状态，为下次回收做准备。

触发条件：
1. 如果没有设置 UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发（线上环境建议带上这个参数，不然会加大问题排查的难度）
2. 老年代使用率达到阈值 CMSInitiatingOccupancyFraction，默认92%
3. 永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction，默认92%，前提是开启 CMSClassUnloadingEnabled
4. 新生代的晋升担保失败(老年代是否有足够的空间来容纳全部的新生代对象或历史平均晋升到老年代的对象，如果不够的话，就提早进行一次老年代的回收，防止下次进行YGC的时候发生晋升失败)

CMS优点：
1. 并发收集
2. 低停顿

CMS缺点：
1. 多线程抢占CPU资源
2. 并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：浮动垃圾。
3. 使用标记-清除算法可能造成大量的空间碎片。空间碎片过多，就会给大对象分配带来麻烦。

总结：
- CMS采用了多种方式尽可能降低GC的暂停时间,减少用户程序停顿。
- 停顿时间降低的同时牺牲了CPU吞吐量。
- 这是在停顿时间和性能间做出的取舍，可以简单理解为"空间(性能)"换时间。

### G1
Garbage First Garbage Collector(优先处理垃圾多的内存块)，使用G1的目的是简化性能优化的复杂性。

比较适合内存稍大一点的应用(一般来说至少4G以上)，小内存的应用还是用传统的垃圾回收器比如CMS比较合适。

G1 GC由Young Generation和Old Generation组成。G1将Java堆空间分割成了若干个Region，即年轻代/老年代是一系列Region的集合，这就意味着在分配空间时不需要一个连续的内存区间，即不需要在JVM启动时决定哪些Region属于老年代，哪些属于年轻代。因为随着时间推移，年轻代Region被回收后，又会变为可用状态（后面会说到的Unused Region或Available Region）了。

G1年轻代收集器是并行Stop-the-world收集器，和其他的HotSpot GC一样，当一个年轻代GC发生时，整个年轻代被回收。G1的老年代收集器有所不同，它在老年代不需要整个老年代回收，只有一部分Region被调用。

G1 GC的年轻代由Eden Region和Survivor Region组成。当一个JVM分配Eden Region失败后就触发一个年轻代回收，这意味着Eden区间满了。然后GC开始释放空间，第一个年轻代收集器会移动所有的存储对象从Eden Region到Survivor Region，这就是“Copy to Survivor”过程。

1. 初始标记(stop the world事件 CPU停顿只处理垃圾)；
2. 并发标记(与用户线程并发执行)；
3. 最终标记(stop the world事件 ,CPU停顿处理垃圾)；
4. 筛选回收(stop the world事件 根据用户期望的GC停顿时间回收)(注意：CMS 在这一步不需要stop the world)

G1如何做到可预测的停顿？
> G1的另一个显著特点他能够让用户设置应用的暂停时间，为什么G1能做到这一点呢？也许你已经注意到了，G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。 (阿里面试)

G1的年轻代收集归纳如下:
1. 堆就是一整块内存空间,被分为多个heap区(regions)。
2. 年轻代内存由一组不连续的heap块也就是region组成. 这使得在需要时很容易进行容量调整。
3. 年轻代的垃圾收集,或者叫 young GCs, 会发生stop the world。 在回收时所有的应用程序线程都会被暂停。
4. 年轻代 GC 通过多线程并行进行。
5. 存活的对象被拷贝到新的 survivor 块或者老年代。

G1的老年代收集归纳如下:
1. 并发标记阶段（Concurrent Marking Phase）
   - 活跃度信息在程序运行的时候就被并行的计算了出来。
   - 活跃度(liveness)信息标记出哪些区域块最适合回收，在转移暂停期间最适合回收掉。
   - 没有sweep阶段。但CMS是有这个阶段的。

2. 重新标记阶段（Remark Phase）
   - 使用了Snapshot-at-the-Beginning (SATB)算法，这个要比CMS的算法快很多。
   - 完全空的区域块会被直接回收掉。

3. 复制/清除阶段（Copying/Cleanup Phase）
   - 年轻代和老年代会被同时回收。
   - 老年代的区域块会不会被选择，取决于它的活跃度。

与其他GC收集器相比，G1具备如下特点：

1. 并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
2. 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。
3. 空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
4. 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，

### ZGC
它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。ZGC最大的问题是浮动垃圾。

1. 并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记和最终标记也会出现短暂的停顿，整个标记阶段只会更新染色指针中的Marked 0、Marked 1标志位。
2. 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。
3. 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。
  > ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，而Shenandoah的Brooks转发指针是每次都会变慢。
  > 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。

4. 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。

动态Region
- 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。
- 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。·
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，最小容量可低至4MB，所有大型Region可能小于中型Region。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。

染色指针技术
- Linux下64位指针的高18位不能用来寻址，所有不能使用；
- Finalizable：表示是否只能通过finalize()方法才能被访问到，其他途径不行；
- Remapped：表示是否进入了重分配集（即被移动过）；
- Marked1、Marked0：表示对象的三色标记状态；
- 最后42用来存对象地址，最大支持4T；

染色指针的三大优势
- 一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。而Shenandoah需要等到更新阶段结束才能释放回收集中的Region，如果Region里面对象都存活的时候，需要1:1的空间才能完成收集。
- 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。
- 染色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

三色标记
- 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

可达性分析的扫描过程，其实就是一股以灰色为波峰的波纹从黑向白推进的过程，但是在并发的推进过程中会产生“对象消失”的问题，如图：

![img](./img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LWY0NDI4NzdkNjQ4YmU2NWIucG5n.png)

对象消失理论，只有同时满足才会发生对象消失：
- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；

要解决对象消失问题只需要破坏其中一条就行了，目前常用有两种方案：

- 增量更新（Incremental Update）:增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
- 原始快照（Snapshot At TheBeginning，SATB）:原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

> 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。

内存多重映射
- ZGC使用了内存多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了

> ZGC的多重映射只是它采用染色指针技术的伴生产物

读屏障
- 当对象从堆中加载的时候，就会使用到读屏障（Load Barrier）。这里使用读屏障的主要作用就是检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有可以直接访问，如果移动过就需要进行“自愈”（对象访问会变慢，但也只会有一次变慢），当“自愈”完成后，后续访问就不会变慢了。

> 读写屏障可以理解成对象访问的“AOP”操作

### Shenandoah
Shenandoah是一款只有OpenJDK才会包含的收集器，最开始由RedHat公司独立发展后来贡献给了OpenJDK，

Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。

相比G1主要改进点在于：
1. 支持并发的整理算法，Shenandoah的回收阶段可以和用户线程并发执行；
2. Shenandoah 目前不使用分代收集，也就是没有年轻代老年代的概念在里面了；
3. Shenandoah 摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。

工作原理：
1. 初始标记（Initial Marking）：与G1一样，只标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。
2. 并发标记（Concurrent Marking） ：与G1一样，从GC Root开始对堆中对象进行可达性分析，找出存活的对象，可与用户线程并发执行，不会造成停顿，时间的长度取决于堆中存活对象的数量和对象图的结构复杂度。
3. 最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set），会有一小段短暂的停顿。
4. 并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。
5. 并发回收（Concurrent Evacuation） ：首先把回收集里面的存活对象先复制一份到其他未被使用的Region之中，然后通过读屏障和Brooks Pointers转发指针技术来解决在垃圾回收期间用户线程继续读写被移动对象的问题，并发回收阶段运行的时间长短取决于回收集的大小。
6. 初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。
7. 并发引用更新（Concurrent Update Reference） ：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
8. 最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。会产生一个非常短暂的停顿，停顿时间只与GC Roots的数量相关。
9. 并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，所以最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。

优缺点：
- 优点：延迟低
- 缺点：高运行负担使得吞吐量下降；使用大量的读写屏障，尤其是读屏障，增大了系统的性能开销

### Epsilon
Release 11 ，HotSpot虚拟机提供的GC. 

特点：一个处理内存分配但不实现任何实际内存回收机制的GC，一旦可用的Java堆耗尽，JVM将关闭。

无操作垃圾收集器对于测量和管理应用程序性能很有用。 活动垃圾收集器是在应用程序旁边的JVM内部运行的复杂程序。 它们会产生开销，从而导致延迟并降低吞吐量。 Epsilon消除了GC对性能的影响。 没有GC循环或读或写障碍。 使用Epsilon GC时，您的代码将独立运行。 您可以使用它来查看垃圾收集如何影响应用程序的性能以及内存阈值是什么，因为它会告诉您何时用完。 如果您认为只需要4 GB的内存，请使用-Xmx4g运行它，看看你是否正确。 如果你错了，请用XX重新运行它：启用HeapDumpOnOutOfMemoryError并查看堆转储以查看你错在哪里

如果您需要从应用程序中挤出所有性能，Epsilon可能是GC的最佳选择。 但是您需要完全了解代码如何使用内存。 如果它几乎没有产生垃圾，或者你确切知道它运行的时间段内使用了多少内存，那么Epsilon是一个可行的选择。

Epsilon GC通过在单个连续的已分配内存块中实现线性分配来工作。这允许GC中的普通无锁TLAB（线程局部分配缓冲区）发布代码，然后可以重用现有VM代码处理的无锁内TLAB分配。发布TLAB还有助于保持由实际分配的进程限制的进程占用驻留内存。

Epsilon使用的屏障集(barrier set )是完全空的/无操作，因为GC不执行任何GC循环，因此不关心对象图，对象标记，对象复制等。由于Epsilon运行时接口的唯一重要部分是发布TLAB，因此其延迟在很大程度上取决于发布的TLAB大小。对于任意大的TLAB和任意大的堆，延迟开销可以通过任意低的正值来描述.

一旦Java堆耗尽，就无法进行分配，也无法进行内存回收，因此我们必须失败。这时有几种选择
1. 使用描述性消息抛出OutOfMemoryError。
2. 执行堆转储（像往常一样启用-XX：+ HeapDumpOnOutOfMemoryError）
3. 执行外部操作（通过通常的-XX：OnOutOfMemoryError = ...），例如，启动调试器或通知外部监视系统有关失败的信息。


## Java字节码执行引擎
### 栈帧（Stack Frame）
用于支持虚拟机进行方法调用和方法执行的数据结构，每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

包括了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。

对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法成为当前方法。

![img](./img/639237-20190629233720793-1323516829.png)

#### 1.局部变量表
局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序中编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。

#### 2.操作数栈
操作数栈（Operand Stack）是一个后进先出栈。同局部变量表一样，操作数栈的最大深度也在编译阶段写入到 Code 属性的 max_stacks 数据项中。操作数栈的每一个元素可以是任意的 Java 数据类型，包括 long 和 double。32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2。在方法执行的任何时候，操作数栈的深度都不会超过 max_stacks 数据项中设定的最大值。

一个方法刚开始执行的时候，该方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈和出栈操作。

#### 3.动态链接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（Dynamic Linking）。Class 文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化成为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

#### 4.方法返回地址
- 正常完成
- 异常退出

无论采用何种退出方式，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上次方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。

#### 5.附加信息
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，成为栈帧信息。


### 方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。

Class文件的编译过程是不包含传统编译中的连接步骤的，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在运行时内存布局中的入口地址（相当于之前说的直接引用）

这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

#### 1.解析
所有方法调用中的目标方法在 Class 文件里都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。

调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。

Java 语言中符合「编译器可知，运行期不可变」这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或者别的方式重写其它版本，因此它们都适合在类加载阶段解析。

与之相应的是，在 Java 虚拟机里提供了 5 条方法调用字节码指令，分别是：
1. invokestatic：调用静态方法；
2. invokespecial：调用实例构造器 方法、私有方法和父类方法；
3. invokevirtual：调用所有虚方法；
4. invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象；
5. invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法 4 类，它们在加载的时候就会把符号引用解析为直接引用。这些方法可以称为非虚方法，与之相反，其它方法称为虚方法（final 方法除外）。

解析调用一定是个静态过程，在编译期间就能完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。

#### 2.分派
面向对象有三个基本特征，封装、继承和多态。这里要说的分派将会揭示多态特征的一些最基本的体现(重载 和 重写)
[静态分派](https://github.com/xiangzz159/JInterview-demo/blob/master/PerformanceTuning/src/main/java/dispatch/StaticDispatch.java)

[静态分派-重载](https://github.com/xiangzz159/JInterview-demo/blob/master/PerformanceTuning/src/main/java/dispatch/Overload.java)

[动态分派-重写](https://github.com/xiangzz159/JInterview-demo/blob/master/PerformanceTuning/src/main/java/dispatch/DynamicDispatch.java)

[单分派、多分派演示](https://github.com/xiangzz159/JInterview-demo/blob/master/PerformanceTuning/src/main/java/dispatch/Dispatch.java)

#### 3.基于栈的字节码解释执行引擎
Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树、再遍历语法树生成字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。

许多 Java 虚拟机的执行引擎在执行 Java 代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。而对于最新的 Android 版本的执行模式则是 AOT + JIT + 解释执行

Java 编译器输出的指令流，基本上是一种基于栈的指令集架构。基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的要受到硬件约束。栈架构的指令集还有一些其他优点，比如相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译实现更加简单（不需要考虑空间分配的问题，所有空间都是在栈上操作）等。

栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。

虽然栈架构指令集的代码非常紧凑，但是完成相同功能需要的指令集数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存中，频繁的栈访问也意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。

## JDK性能监控于故障处理

### jps
作用：用于查看虚拟机运行了那些进程，并输出这些进程LVMID，即进程id，它是使用最频繁的一个命令，因为其它工具需要依赖jps。首先需要jps输出jvm正在运行的的进程id；然后其它工具根据进程id进行监控对应的进程运行情况。
```shell script
[root@localhost ~]# jps [options] [hostid]
```
|选项|作用|
|:--:|:--:|
|-q|只输出LVMID，省略主类名|
|-m|输出虚拟机进程启动时传递给主类main()函数的参数|
|-l|输出主类全类名，如果进程执行的是jar包，输出jar路径|
|-v|输出虚拟机进程的JVM启动参数|

### jmap
作用：内存映像工具，可用生成堆内存转存快照dump，它还可以查询finalize执行队列，java堆和永久代的详细信息，例如：空间利用率，当前用的是那种收集器等。
```shell script
[root@localhost ~]# jmap [option] vmid
```
|选项|作用|
|:--:|:--:|
|-dump|生成Java堆转储快照。格式为:-dump:[live, ]formate=b,file=<filename>,其中live子参数说明是否只jump出存活的对象|
|-finalizeinfo|显示在F-Queue中等待Finalizer线程执行finalize方法的对象，只在Linux/Solaris平台下有效|
|-heap|显示java堆详细信息，如使用那种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效|
|-histo|显示堆中对象统计信息，包括类、实例数量、合计容量|
|-permstat|在ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效|
|-F|当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dunp快照。只在Linux/Solaris平台下有效|

### jstat
作用：用于jvm虚拟机统计信息监控的，主要用于监控jvm内存使用率。
```shell script
[root@localhost ~]# jstat [option vmid [ interval [s | ms] [ count] ] ]
```
|选项|作用|
|:--:|:--:|
|-class|监视类装载、卸载数量、总空间以及类装载所耗的时间|
|-gc|监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息|
|-gccapacity|监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间|
|-gcutil|监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比|
|-gccause|与-gcutil功能一样，但是会额外输出导致上一次GC产出的原因|
|-gcnew|监视新生代GC状况|
|-gcnewcapacity|监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间|
|-gcold|监视老年代GC状况|
|-gcoldcapacity|监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间|
|-gcpermcapacity|输出永久代使用到的最大、最小空间|
|-compiler|输出JIT编译器编译过的方法、耗时等信息|
|-printcompilation|输出已经被JIT编译的方法|
### jinfo
作用：实时查看java配置信息工具，它也可以实时调整虚拟机各项配置参数的值。
```shell script
[root@localhost ~]# jinfo [option] vmid
```

### jhat
作用：用于分析jmap生成的内存快照
```shell script
[root@localhost ~]# jhat [ options ] heap-dump-file
```

### jstack
作用：用于生成虚拟机当前时刻的线程快照，定位线程长时间停顿的原因。
```shell script
[root@localhost ~]# ``jstack [ options ] vmid
```

## JVM服务器实战调优
### GCView
### Arthas

# MySQL
## MySQL优化基础
## 多版本并发控制MVCC
## 应用程序性能剖析
## 慢查询日志剖析
## 数据库优化与索引
## BTree索引/Hash索引/聚簇索引/非聚簇索引
## 索引的选择和表的维护
## 深入索引原理解析
## 高效索引策略与SQL查询优化
## SQL优化查询器

# Tomcat
## Tomcat概述
## Web引用通信机制
## Tomcat重要核心组件
## Tomcat类加载器
## Tomcat内部原理与线程模型
## HTTP协议和BIO/NIO
## Tomcat高可用集群架构方案
## Tomcat高可用集群架构实现
## Tomcat性能调用实战
