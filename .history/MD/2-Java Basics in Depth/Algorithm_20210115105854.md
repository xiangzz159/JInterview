- [常用算法](#常用算法)
  - [搜索](#搜索)
    - [二分](#二分)
  - [排序](#排序)
    - [选择](#选择)
    - [插入](#插入)
    - [快速](#快速)
    - [归并](#归并)
    - [堆](#堆)
    - [基数](#基数)
- [高级算法](#高级算法)
  - [分而治之](#分而治之)
  - [贪婪](#贪婪)
  - [动态规划](#动态规划)
  - [回溯](#回溯)
  - [分支限界](#分支限界)
- [一致性算法](#一致性算法)
  - [Paxos](#paxos)
  - [Raft](#raft)
  - [gossip](#gossip)
- [大数据算法](#大数据算法)
  - [Hash分桶](#hash分桶)
  - [Hash统计](#hash统计)

# 常用算法
## 搜索
### 二分
简单的二分搜索
```Java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) { // 注意
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
        }
    return -1;
}
```
此算法缺陷：

比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见。你也许会说，找到一个 target 索引，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的时间复杂度了。

我们后续的算法就来讨论这两种二分查找的算法。

```Java
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意

    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```


## 排序
### 选择
### 插入
### 快速
### 归并
### 堆
### 基数

# 高级算法
## 分而治之
## 贪婪
## 动态规划
## 回溯
## 分支限界

# 一致性算法
## Paxos
## Raft
## gossip

# 大数据算法
## Hash分桶
## Hash统计