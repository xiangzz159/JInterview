- [设计模式基本原则](#设计模式基本原则)
  - [开闭原则](#开闭原则)
  - [里氏替换原则](#里氏替换原则)
  - [依赖倒置原则](#依赖倒置原则)
  - [单一职责原则](#单一职责原则)
  - [接口隔离原则](#接口隔离原则)
  - [迪米特法则](#迪米特法则)
  - [合成复用原则](#合成复用原则)
- [创新性模式](#创新性模式)
  - [单例模式（Sigleton）](#单例模式sigleton)
  - [原型模式（Prototype）](#原型模式prototype)
  - [工厂模式（Factory）](#工厂模式factory)
  - [建造者模式（Builder）](#建造者模式builder)
- [行为型模式](#行为型模式)
  - [模版方法（Template）](#模版方法template)
  - [策略模式（Strategy）](#策略模式strategy)
  - [命令模式（Command）](#命令模式command)
  - [责任链模式（Chain）](#责任链模式chain)
  - [状态模式（State）](#状态模式state)
  - [观察者模式（Observer）](#观察者模式observer)
  - [中介者模式（Mediator）](#中介者模式mediator)
  - [访问者模式（Visitor）](#访问者模式visitor)
  - [迭代器模式（Iterator）](#迭代器模式iterator)
  - [备忘录模式（Memento）](#备忘录模式memento)
  - [解释器模式（Interpreter）](#解释器模式interpreter)
- [结构型模式](#结构型模式)
  - [代理模式（Proxy）](#代理模式proxy)
  - [适配器模式（Adapter）](#适配器模式adapter)
  - [桥接模式（Bridger）](#桥接模式bridger)
  - [装饰器模式（Decorator）](#装饰器模式decorator)
  - [外观模式（Facade）](#外观模式facade)
  - [组合模式（Composite）](#组合模式composite)
  - [享元模式（Flyweight）](#享元模式flyweight)

# 设计模式基本原则
|模式 & 描述|包括|
|:--:|:--|
|创建型模式|这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。<br>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）|
|结构型模式|这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。<br>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）|
|行为型模式|这些设计模式特别关注对象之间的通信。<br>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）|
|J2EE 模式|这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。<br>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）|

![img](./img/the-relationship-between-design-patterns.png)
## 开闭原则
开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

## 里氏替换原则
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

## 依赖倒置原则
这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
## 单一职责原则
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

## 接口隔离原则
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

## 迪米特法则
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

## 合成复用原则
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

# 创新性模式
## 单例模式（Sigleton）
意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

主要解决：一个全局使用的类频繁地创建与销毁。

何时使用：当您想控制实例数目，节省系统资源的时候。

如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

关键代码：构造函数是私有的。

应用实例：
1. 一个班级只有一个班主任。
2. Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
3. 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

优点：
1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
2. 避免对资源的多重占用（比如写文件操作）。


缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

使用场景：
1. 要求生产唯一序列号。
2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
> 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

单例类型：
1. 懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。[[1]](https://github.com/xiangzz159/JInterview-demo/blob/master/DesignPatterns/src/main/java/com/mydesign/singleton/Lazy1.java)
2. 饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。[[2]](https://github.com/xiangzz159/JInterview-demo/blob/master/DesignPatterns/src/main/java/com/mydesign/singleton/Hungry1.java)
3. 双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。[[3]](https://github.com/xiangzz159/JInterview-demo/blob/master/DesignPatterns/src/main/java/com/mydesign/Singleton/Lazy3.java)
4. 静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。[[4]](https://github.com/xiangzz159/JInterview-demo/blob/master/DesignPatterns/src/main/java/com/mydesign/Singleton/InnerClass.java)
5. 枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。[[5]](https://github.com/xiangzz159/JInterview-demo/blob/master/DesignPatterns/src/main/java/com/mydesign/Singleton/EnumSingleton.java)

[面试题1](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650127610&idx=2&sn=cf043f3b38d1a9f99db147c4af2ee5d6&chksm=f36ba1dbc41c28cd79ec02d27da1805c9f7234c06dd195dfd957212b3c0f291225e778880538&scene=126&sessionid=1589247405&key=b152a177cb32a70e8469b2aaa790a338fc772f752fcc769894c4e85c818043c5486d64bdebe2f7db00570fed58e15413ccbc59e8b7bbda85c142fc9d05764bd9f49f22fd5b42633d41a77f3cb2bc7823&ascene=1&uin=MTI3NDQ2OTMxMw%3D%3D&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=A6MtRuoQxjxlKeeXPIsfnr8%3D&pass_ticket=x%2BEl%2By4e9M6qmg1SJOCRDdhQPXlqbdrNhYEEvFuczalnq%2FWaOdYdI33chG2UfDrv)

## 原型模式（Prototype）
意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

主要解决：在运行期建立和删除原型。

何时使用： 
1. 当一个系统应该独立于它的产品创建，构成和表示时。 
2. 当要实例化的类是在运行时刻指定时，例如，通过动态装载。
3. 为了避免创建一个与产品类层次平行的工厂类层次时。 
4. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。

关键代码： 
1. 实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 
2. 原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

应用实例： 
1. 细胞分裂。 
2. JAVA 中的 Object clone() 方法。

优点： 
1. 性能提高。 
2. 逃避构造函数的约束。

缺点： 
1. 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 
2. 必须实现 Cloneable 接口。

使用场景： 
1. 资源优化场景。 
2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 
3. 性能和安全要求的场景。 
4. 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 
5. 一个对象多个修改者的场景。 
6. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 
7. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

> 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。

浅拷贝：
当类的成员变量是基本数据类型时，浅拷贝会复制该属性的值赋值给新对象。2、当成员变量是引用数据类型时，浅拷贝复制的是引用数据类型的地址值。这种情况下，当拷贝出的某一个类修改了引用数据类型的成员变量后，会导致所有拷贝出的类都发生改变。[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Prototype/demo1)

深拷贝：
深拷贝不仅会复制成员变量为基本数据类型的值，给新对象。还会给是引用数据类型的成员变量申请储存空间，并复制引用数据类型成员变量的对象。这样拷贝出的新对象就不怕修改了是引用数据类型的成员变量后，对其它拷贝出的对象造成影响了。[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Prototype/demo2)

## 工厂模式（Factory）
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

主要解决：主要解决接口选择的问题。

何时使用：我们明确地计划不同条件下创建不同实例时。

如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

关键代码：创建过程在其子类执行。

[简单工厂](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Factory/SimpleFactory)

- 特点
  1. 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。
  2. create()方法通常是静态的，所以也称之为静态工厂。

- 缺点
  1. 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）
  2. 不同的产品需要不同额外参数的时候 不支持。

[工厂模式](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Factory/FactoryMethod)

1. 模式描述
   - 提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。

2. 模式作用
   - 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。
   - 可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。
   - 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。
   - 另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。

3. 适用场景
   - 消费者不关心它所要创建对象的类(产品类)的时候。
   - 消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。

4. 模式要素
   - 提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。
   - 提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。
   - 由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。

[抽象工厂](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Factory/AbstractFactory)

1. 抽象工厂模式与工厂方法模式的区别
   - 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。
   - 在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。
2. 抽象工厂模式的优点
   - 抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。
3. 抽象工厂模式的缺点
   - 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。
4. 适用场景
   - 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。

无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。

所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。



> 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
## 建造者模式（Builder）
意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

何时使用：一些基本部件不会变，而其组合经常变化的时候。

如何解决：将变与不变分离开。

关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

应用实例： 
1. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 
2. JAVA 中的 StringBuilder。

优点：
1. 建造者独立，易扩展。 
2. 便于控制细节风险。可以对建造过程逐步细化，而不对其他模块产生任何影响。
3. 封装性。是客户端不必知道产品内部组成的细节。

缺点： 
1. 产品必须有共同点，范围有限制。 
2. 如内部变化复杂，会有很多的建造类。

使用场景：
1. 需要生成的对象具有复杂的内部结构。 
2. 相同的方法，不同的执行顺序，产生不同的事件结果时。
3. 多个部件或零件，都可以装配到一个对象中，但产生的结果又不相同时。

与工厂模式的区别:
- 建造者模式更关注于零件装配的顺序

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Builder/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Builder/demo2)

> 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
# 行为型模式
## 模版方法（Template）
意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

主要解决：一些方法通用，却在每一个子类都重新写了这一方法。

何时使用：有一些通用的方法。

如何解决：将这些通用算法抽象出来。

关键代码：在抽象类实现，其他步骤在子类实现。

应用实例： 
1. 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 
2. 西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 
3. spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。

优点： 
1. 封装不变部分，扩展可变部分。 
2. 提取公共代码，便于维护。 
3. 行为由父类控制，子类实现。

缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

使用场景： 
1. 有多个子类共有的方法，且逻辑相同。 
2. 重要的、复杂的方法，可以考虑作为模板方法。

> 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Template/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Template/demo2)

## 策略模式（Strategy）
意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

如何解决：将这些算法封装成一个一个的类，任意地替换。

关键代码：实现同一个接口。

应用实例： 
1. 诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 
2. 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 
3. JAVA AWT 中的 LayoutManager。

优点： 
1. 算法可以自由切换。 
2. 避免使用多重条件判断。 
3. 扩展性良好。

缺点： 
1. 策略类会增多。 
2. 所有策略类都需要对外暴露。

使用场景： 
1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 
2. 一个系统需要动态地在几种算法中选择一种。 
3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

> 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Strategy/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Strategy/demo2)

## 命令模式（Command）
意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。

何时使用：在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。

关键代码：定义三个角色：
1. received 真正的命令执行对象 
2. Command 
3. invoker 使用命令对象的入口

应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。

优点： 
1. 降低了系统耦合度。 
2. 新的命令可以很容易添加到系统中去。

缺点：使用命令模式可能会导致某些系统有过多的具体命令类。

使用场景：认为是命令的地方都可以使用命令模式，比如：
1. GUI 中每一个按钮都是一条命令。 
2. 模拟 CMD。

> 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Command/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Command/demo2)

命令模式结构示意图:
## 责任链模式（Chain）
意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

何时使用：在处理消息的时候以过滤很多道。

如何解决：拦截的类都实现统一接口。

关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

应用实例： 
1. 红楼梦中的"击鼓传花"。 
2. JS 中的事件冒泡。 
3. JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。

优点： 
1. 降低耦合度。它将请求的发送者和接收者解耦。 
2. 简化了对象。使得对象不需要知道链的结构。 
3. 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 
4. 增加新的请求处理类很方便。

缺点： 
1. 不能保证请求一定被接收。 
2. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
3. 可能不容易观察运行时的特征，有碍于除错。

使用场景： 
1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 
2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 
3. 可动态指定一组对象处理请求。

> 注意事项：在 JAVA WEB 中遇到很多应用。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Chain/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Chain/demo2)

[demo3](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Chain/demo3)

## 状态模式（State）
意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

何时使用：代码中包含大量与对象状态有关的条件语句。

如何解决：将各种具体的状态类抽象出来。

关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。

应用实例： 
1. 打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 
2. 曾侯乙编钟中，'钟是抽象接口','钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。

优点： 
1. 封装了转换规则。 
2. 枚举可能的状态，在枚举状态之前需要确定状态种类。 
3. 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 
4. 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 
5. 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

缺点： 
1. 状态模式的使用必然会增加系统类和对象的个数。 
2. 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 
3. 状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

使用场景： 
1. 行为随状态改变而改变的场景。 
2. 条件、分支语句的代替者。

> 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/State/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/State/demo2)

[demo3](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/State/demo3)

[demo4](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/State/demo4)

## 观察者模式（Observer）
意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

如何解决：使用面向对象技术，可以将这种依赖关系弱化。

关键代码：在抽象类里有一个 ArrayList 存放观察者们。

应用实例： 
1. 拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 
2. 西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

优点： 
1. 观察者和被观察者是抽象耦合的。 
2. 建立一套触发机制。

缺点： 
1. 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 
2. 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 
3. 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

使用场景：
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

> 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Observer/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Observer/demo2)

[demo3](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Observer/demo3)


## 中介者模式（Mediator）
意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。

何时使用：多个类相互耦合，形成了网状结构。

如何解决：将上述网状结构分离为星型结构。

关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。

应用实例： 
1. 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 
2. 机场调度系统。 
3. MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。

优点： 
1. 降低了类的复杂度，将一对多转化成了一对一。 
2. 各个类之间的解耦。 
3. 符合迪米特原则。

缺点：中介者会庞大，变得复杂难以维护。

使用场景： 
1. 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 
2. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

> 注意事项：不应当在职责混乱的时候使用。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Mediator/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Mediator/demo2)

## 访问者模式（Visitor）
意图：主要将数据结构与数据操作分离。

主要解决：稳定的数据结构和易变的操作耦合问题。

何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。

如何解决：在被访问的类里面加一个对外提供接待访问者的接口。

关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。

优点： 
1. 符合单一职责原则。 
2. 优秀的扩展性。 
3. 灵活性。

缺点： 
1. 具体元素对访问者公布细节，违反了迪米特原则。 
2. 具体元素变更比较困难。 
3. 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

使用场景： 
1. 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 
2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。

> 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Visitor/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Visitor/demo2)

## 迭代器模式（Iterator）
意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

主要解决：不同的方式来遍历整个整合对象。

何时使用：遍历一个聚合对象。

如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。

关键代码：定义接口：hasNext, next。

应用实例：JAVA 中的 iterator。

优点： 
1. 它支持以不同的方式遍历一个聚合对象。 
2. 迭代器简化了聚合类。 
3. 在同一个聚合上可以有多个遍历。 
4. 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

使用场景： 
1. 访问一个聚合对象的内容而无须暴露它的内部表示。 
2. 需要为聚合对象提供多种遍历方式。 
3. 为遍历不同的聚合结构提供一个统一的接口。

> 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Iterator/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Iterator/demo2)

## 备忘录模式（Memento）
意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。

如何解决：通过一个备忘录类专门存储对象状态。

关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。

应用实例： 
1. 后悔药。 
2. 打游戏时的存档。 
3. Windows 里的 ctri + z。 
4. IE 中的后退。 
5. 数据库的事务管理。

优点： 
1. 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 
2. 实现了信息的封装，使得用户不需要关心状态的保存细节。

缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

使用场景： 
1. 需要保存/恢复数据的相关状态场景。 
2. 提供一个可回滚的操作。

> 注意事项： 
> 1. 为了符合迪米特原则，还要增加一个管理备忘录的类。 
> 2. 为了节约内存，可使用原型模式+备忘录模式。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Memento/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Memento/demo2)


## 解释器模式（Interpreter）
意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

主要解决：对于一些固定文法构建一个解释句子的解释器。

何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

如何解决：构建语法树，定义终结符与非终结符。

关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。

应用实例：编译器、运算表达式计算。

优点： 
1. 可扩展性比较好，灵活。 
2. 增加了新的解释表达式的方式。 
3. 易于实现简单文法。

缺点： 
1. 可利用场景比较少。 
2. 对于复杂的文法比较难维护。 
3. 解释器模式会引起类膨胀。
4. 解释器模式采用递归调用方法。

使用场景： 
1. 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 
2. 一些重复出现的问题可以用一种简单的语言来进行表达。
3. 一个简单语法需要解释的场景。

> 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Interpreter/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Interpreter/demo2)

# 结构型模式
## 代理模式（Proxy）
意图：为其他对象提供一种代理以控制对这个对象的访问。

主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

何时使用：想在访问一个类时做一些控制。

如何解决：增加中间层。

关键代码：实现与被代理类组合。

应用实例： 
1. Windows 里面的快捷方式。 
2. 猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 
3. 买火车票不一定在火车站买，也可以去代售点。 
4. 一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。
5. spring aop。

优点： 
1. 职责清晰。 
2. 高扩展性。 
3. 智能化。

缺点： 
1. 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
2. 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

使用场景：按职责来划分，通常有以下使用场景： 
1. 远程代理。 
2. 虚拟代理。 
3. Copy-on-Write 代理。 
4. 保护（Protect or Access）代理。 
5. Cache代理。 
6. 防火墙（Firewall）代理。 
7. 同步化（Synchronization）代理。 
8. 智能引用（Smart Reference）代理。

> 注意事项： 
> 1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
> 2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Proxy/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Proxy/demo2)

## 适配器模式（Adapter）

意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

如何解决：继承或依赖（推荐）。

关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。

应用实例： 
1. 美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 
2. JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 
3. 在 LINUX 上运行 WINDOWS 程序。 
4. JAVA 中的 jdbc。

优点： 
1. 可以让任何两个没有关联的类一起运行。 
2. 提高了类的复用。 
3. 增加了类的透明度。 
4. 灵活性好。

缺点： 
1. 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 
2. 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

> 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Adapter/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Adapter/demo2)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Adapter/demo3)

## 桥接模式（Bridger）
意图：将抽象部分与实现部分分离，使它们都可以独立的变化。

主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。

如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

关键代码：抽象类依赖实现类。

应用实例： 
1. 猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 
2. 墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

优点： 
1. 抽象和实现的分离。 
2. 优秀的扩展能力。 
3. 实现细节对客户透明。

缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

使用场景： 
1. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 
2. 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 
3. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

> 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Bridger/demo1)

## 装饰器模式（Decorator）
意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

何时使用：在不想增加很多子类的情况下扩展类。

如何解决：将具体功能职责划分，同时继承装饰者模式。

关键代码： 
1. Component 类充当抽象角色，不应该具体实现。 
2. 修饰类引用和继承 Component 类，具体扩展类重写父类方法。

应用实例： 
1. 孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 
2. 不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。

优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

缺点：多层装饰比较复杂。

使用场景： 
1. 扩展一个类的功能。 
2. 动态增加功能，动态撤销。

> 注意事项：可代替继承。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Decorator/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Decorator/demo2)

## 外观模式（Facade）
意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。

何时使用： 
1. 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 
2. 定义系统的入口。

如何解决：客户端不与系统耦合，外观类与系统耦合。

关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

应用实例： 
1. 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 
2. JAVA 的三层开发模式。

优点： 
1. 减少系统相互依赖。 
2. 提高灵活性。 
3. 提高了安全性。

缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

使用场景： 
1. 为复杂的模块或子系统提供外界访问的模块。 
2. 子系统相对独立。 
3. 预防低水平人员带来的风险。

> 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Facade/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Facade/demo2)
## 组合模式（Composite）
意图：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

何时使用： 
1. 您想表示对象的部分-整体层次结构（树形结构）。 
2. 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。

关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

应用实例： 
1. 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 
2. 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

优点： 
1. 高层模块调用简单。 
2. 节点自由增加。

缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。

> 注意事项：定义时为具体类。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Composite/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Composite/demo2)

[demo3](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Composite/demo3)

## 享元模式（Flyweight）
意图：运用共享技术有效地支持大量细粒度的对象。

主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

何时使用： 
1. 系统中有大量对象。 
2. 这些对象消耗大量内存。 
3. 这些对象的状态大部分可以外部化。 
4. 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 
5. 系统不依赖于这些对象身份，这些对象是不可分辨的。

如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

关键代码：用 HashMap 存储这些对象。

应用实例： 
1. JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 
2. 数据库的数据池。

优点：大大减少对象的创建，降低系统的内存，使效率提高。

缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

使用场景： 
1. 系统有大量相似对象。 
2. 需要缓冲池的场景。

> 注意事项： 
> 1. 注意划分外部状态和内部状态，否则可能会引起线程安全问题。 
> 2. 这些类必须有一个工厂对象加以控制。

[demo1](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Flyweight/demo1)

[demo2](https://github.com/xiangzz159/JInterview-demo/tree/master/DesignPatterns/src/main/java/com/mydesign/Flyweight/demo2)