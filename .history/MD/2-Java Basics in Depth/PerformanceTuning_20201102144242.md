- [JVM](#jvm)
  - [实现原理](#实现原理)
  - [加载过程](#加载过程)
  - [JVM内存模型](#jvm内存模型)
  - [Java类文件结构](#java类文件结构)
  - [Java虚拟机类加载机制与类加载器](#java虚拟机类加载机制与类加载器)
  - [运行时数据区：深入连接堆/栈/元空间](#运行时数据区深入连接堆栈元空间)
  - [垃圾回收机制](#垃圾回收机制)
    - [CMS](#cms)
    - [G1](#g1)
    - [ZGC](#zgc)
    - [Shenandoah](#shenandoah)
    - [Epsilon](#epsilon)
  - [Java字节码执行引擎](#java字节码执行引擎)
  - [JKD性能监控于故障处理](#jkd性能监控于故障处理)
  - [JVM服务器实战调优](#jvm服务器实战调优)
    - [GCView](#gcview)
    - [Arthas](#arthas)
  - [JVM面试题解析](#jvm面试题解析)
- [MySQL](#mysql)
  - [MySQL优化基础](#mysql优化基础)
  - [多版本并发控制MVCC](#多版本并发控制mvcc)
  - [应用程序性能剖析](#应用程序性能剖析)
  - [慢查询日志剖析](#慢查询日志剖析)
  - [数据库优化与索引](#数据库优化与索引)
  - [BTree索引/Hash索引/聚簇索引/非聚簇索引](#btree索引hash索引聚簇索引非聚簇索引)
  - [索引的选择和表的维护](#索引的选择和表的维护)
  - [深入索引原理解析](#深入索引原理解析)
  - [高效索引策略与SQL查询优化](#高效索引策略与sql查询优化)
  - [SQL优化查询器](#sql优化查询器)
- [Tomcat](#tomcat)
  - [Tomcat概述](#tomcat概述)
  - [Web引用通信机制](#web引用通信机制)
  - [Tomcat重要核心组件](#tomcat重要核心组件)
  - [Tomcat类加载器](#tomcat类加载器)
  - [Tomcat内部原理与线程模型](#tomcat内部原理与线程模型)
  - [HTTP协议和BIO/NIO](#http协议和bionio)
  - [Tomcat高可用集群架构方案](#tomcat高可用集群架构方案)
  - [Tomcat高可用集群架构实现](#tomcat高可用集群架构实现)
  - [Tomcat性能调用实战](#tomcat性能调用实战)


# JVM
JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。

## 实现原理
1. jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。
2. java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码，通过特定平台运行。

![img](./img/1587882-20190308111205469-1550734334.png)

## 加载过程
1. 加载.class文件
2. 管理并分配内存 
3. 执行垃圾收集

![img](./img/1587882-20190308115512915-365586565.png)

 如上图所示，首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

## JVM内存模型
JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)

![img](./img/1587882-20190308115822736-2106039872)

如图所示jvm内存划分为五部分
- 方法区（Method Area）  
  方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常。
- 堆区（Heap）  
  堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。
- 虚拟机栈（VM Stack）  
  虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。
- 本地方法栈（Native Method Stack）  
  本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。
- 程序计数器（Program Counter Register）  
  程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它，它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。

## Java类文件结构
## Java虚拟机类加载机制与类加载器
## 运行时数据区：深入连接堆/栈/元空间
## 垃圾回收机制
### CMS
### G1
### ZGC
### Shenandoah
### Epsilon
## Java字节码执行引擎
## JKD性能监控于故障处理
## JVM服务器实战调优
### GCView
### Arthas
## JVM面试题解析

# MySQL
## MySQL优化基础
## 多版本并发控制MVCC
## 应用程序性能剖析
## 慢查询日志剖析
## 数据库优化与索引
## BTree索引/Hash索引/聚簇索引/非聚簇索引
## 索引的选择和表的维护
## 深入索引原理解析
## 高效索引策略与SQL查询优化
## SQL优化查询器

# Tomcat
## Tomcat概述
## Web引用通信机制
## Tomcat重要核心组件
## Tomcat类加载器
## Tomcat内部原理与线程模型
## HTTP协议和BIO/NIO
## Tomcat高可用集群架构方案
## Tomcat高可用集群架构实现
## Tomcat性能调用实战
