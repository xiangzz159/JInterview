# Linux操作系统

# 目录
- [Linux简介](#linux简介)
- [Linux虚拟机环境搭建](#linux虚拟机环境搭建)
- [Linux主流发行版本和特点](#linux主流发行版本和特点)
- [Linux使用](#linux使用)
- [Linux核心理解](#linux核心理解)

## Linux简介
1. 1965年，美国麻省理工学院（MIT）. 通用电器公司（GE）及AT&T的贝尔实验室联合开发Multics工程计划，其目标是开发一种交互式的具有多道程序处理能力的分时操作系统，但因Multics追求的目标过于庞大复杂，项目进度远远落后于计划，最后贝尔实验室宣布退出。
2. 1969年，美国贝尔实验室的肯·汤普森在DEC PDP-7机器上开发出了UNIX系统
3. 1971年，肯·汤普森的同事丹尼斯·里奇发明了C语言。1973年，UNIX系统的绝大部分源代码用C语言重写，这为提高UNIX系统的可移植性打下基础
4. Linux系统诞生与1991年，由芬兰大学生利纳斯（Linux Torvalds）和后来陆续加入的众多爱好者共同开发完成。Linux是开源软件，源代码开发的UNIX  
[Linux内核官网](http://www.kernel.org)

## Linux虚拟机环境搭建
1. 安装[VMWare](https://www.vmware.com/cn.html)虚拟机
2. 在VM上安装Linux系统镜像,安装镜像可以通过响应的Linux发行版本官网下载。
3. 设置密码，重启系统，安装所需的软件。


## Linux主流发行版本和特点
### UNIX主流发行版本
|  操作系统 | 公司 |  硬件平台 |
|:-----:|:-----:|:-----:|
|AIX |  IBM  |   PowerPC  |
|HP-UX  |  HP  |   PA-RISC  |
|Solaris |  Sun  |   SPARC  |
|Linux |  CentOS、Ubuntu......  |   IA(Inter、AMD、Cyrix......)  |

### Linux主流发行版本
| 操作系统 | 特点分类 | 特点 |
|:-----:|:-----:|:-----:|
|[Redhat](https://www.redhat.com/en) |  redhat  |  技术支持较，用户界面友好，硬件的兼容性好，采用基于Deb的ATP包管理系统；技术支持和更新服务是需要付费的, 服务器软件生态系统的规模和活力方面稍弱  |
|[Centos](https://www.centos.org/) |  redhat  |  与包括更新在内的服务完全免费，具备良好的社区技术支持，如果需要更专业级别的支持，那么还可以平滑的从CentOS转至RHEL，采用基于yum的RMP包管理系统；不提供专门技术支持，不包含封闭源代码软件；更新服务较为滞后，当然开发团队的可靠性也无法与上面3类商业版本Linux相比。  |
|[Deepin](https://www.deepin.org/) |  debian  |  基于debian，以易用、美观、完善著称；社区还不完善  |
|[Debian](https://www.debian.org/) |  debian  |  精简而稳定，deb包高度集中，依赖性问题少，拥有最大的支持社区；由于它是完全自由的操作系统，因此没有专业的技术支持。另外它的更新周期很长，软件库里很多软件也显得老旧了  |
|[Ubuntu](https://ubuntu.com/) |  debian  |  社区活跃，软件数量众多；但是Unity桌面的性能很低，并且不是很稳定，常常卡死。内置的软件大多数没用，你通常要花上一个星期才能把ubuntu打造成适合自己的系统。  |
|[CoreOS](http://coreos.com/) |  other  |  对容器云的支持，能够方便的部署Kubernetes集群，直接无缝支持docker容器云的部署；但是etcd因为国情限制不能不能很好的部署，需要自己配置DNS才能完整部署  |
[Linux的发行版本及不同版本的联系和区别](https://www.jianshu.com/p/c88a62ac8ca3)

## Linux使用
- [Vim](#vim)
- [程序安装](#程序安装)
- [用户和用户组管理](#用户和用户组管理)
- [权限管理](#权限管理)
- [文件系统](#文件系统)
- [Shell](./Shell.md)
- [服务管理](#服务管理)
- [系统管理](#系统管理)
- [日志管理](#日志管理)
- [启动管理](#启动管理)
- [备份与恢复](#备份与恢复)
- [the-art-of-command-line](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md)
- [命令大全](https://man.linuxde.net/)

### Vim
1. 简介：Vim是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列成为类Unix系统用户最喜欢的文本编辑器。  
&ensp;&ensp;&ensp;&ensp;Vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。同时VIM与很多快捷键设置和正则表达式类似,可以辅助记忆。并且vim针对程序员做了优化。  

![vim键盘图片](./img/vi-vim-cheat-sheet-sch.png "vim键盘图")

2. vim模式：基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：
   - 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。  
以下是常用的几个命令：
     - i 切换到输入模式，以输入字符。
     - x 删除当前光标所在处的字符。
     - : 切换到底线命令模式，以在最底一行输入命令。
     - 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。

   - 输入模式：在命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键：
     - 字符按键以及Shift组合，输入字符
     - ENTER，回车键，换行
     - BACK SPACE，退格键，删除光标前一个字符
     - DEL，删除键，删除光标后一个字符
     - 方向键，在文本中移动光标
     - HOME/END，移动光标到行首/行尾
     - Page Up/Page Down，上/下翻页
     - Insert，切换光标为输入/替换模式，光标将变成竖线/下划线
     - ESC，退出输入模式，切换到命令模式

    - 底线命令模式：在命令模式下按下“:”（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）：
      - q 退出程序
      - w 保存文件
      - 按ESC键可随时退出底线命令模式。

&ensp;&ensp;简单的说，我们可以将这三个模式想成底下的图标来表示：
![vim模式](./img/vim-vi-workmodel.png "vim模式")

#### 优点
- 命令丰富，几乎能满足文本编辑的所有操作
- 对硬件要求不高
- 开源，插件丰富
- 速度快（运行，使用）
#### 缺点
- 学习曲线陡峭，对初学者不友好
- vim内置脚本语言有局限性，开发效率比不上专业的程序开发软件

#### 常用命令：
- h 或 向左箭头键(←)：光标向左移动一个字符
- j 或 向下箭头键(↓)：光标向下移动一个字符
- k 或 向上箭头键(↑)：光标向上移动一个字符
- l 或 向右箭头键(→)：光标向右移动一个字符
- [Ctrl] + [f]：屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)
- [Ctrl] + [b]：屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)
- [Ctrl] + [d]：屏幕『向下』移动半页
- [Ctrl] + [u]：屏幕『向上』移动半页
- G：移动到这个档案的最后一行(常用)
- nG：n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)
- gg：移动到这个档案的第一行，相当于 1G 啊！ (常用)
- n<Enter>：n 为数字。光标向下移动 n 行(常用)
- /word：向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)
- ?word：向光标之上寻找一个字符串名称为 word 的字符串。
- n：这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！
- N：这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。
- dd：删除游标所在的那一整行(常用)
- ndd：n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)
- d1G：删除光标所在到第一行的所有数据
- dG：删除光标所在到最后一行的所有数据
- yy：复制游标所在的那一行(常用)
- nyy：n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)
- [Esc]：退出编辑模式，回到一般模式中(常用)
- :w：将编辑的数据写入硬盘档案中(常用)
- :w!：若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！
- :q：离开 vi (常用)
- :q!：若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。  
注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～
- :wq：储存后离开，若为 :wq! 则为强制储存后离开 (常用)

### 程序安装
- rpm包安装方式步骤
  1. 找到相应的软件包，比如soft.version.rpm，下载到本机某个目录；
  2. 打开一个终端，su -成root用户；
  3. cd soft.version.rpm所在的目录；
  4. 输入rpm -ivh soft.version.rpm
- deb包安装方式步骤:
  1. 找到相应的软件包，比如soft.version.deb，下载到本机某个目录；
  2. 打开一个终端，su -成root用户；
  3. cd soft.version.deb所在的目录；
  4. 输入dpkg -i soft.version.deb
- tar.gz源代码包安装方式：
  1. 找到相应的软件包，比如soft.tar.gz，下载到本机某个目录；
  2. 打开一个终端，su -成root用户；
  3. cd soft.tar.gz所在的目录；
  4. tar -xzvf soft.tar.gz //一般会生成一个soft目录
  5. cd soft
  6. ./configure
  7. make
  8. make install
- tar.bz2源代码包安装方式：
  1. 找到相应的软件包，比如soft.tar.bz2，下载到本机某个目录；
  2. 打开一个终端，su -成root用户；
  3. cd soft.tar.bz2所在的目录；
  4. tar -xjvf soft.tar.bz2 //一般会生成一个soft目录
  5. cd soft
  6. ./configure
  7. make
  8. make install
- apt方式安装：（安装deb包）
  1. 打开一个终端，su -成root用户；
  2. apt-cache search soft 注：soft是你要找的软件的名称或相关信息
  3. 如果2中找到了软件soft.version，则用apt-get install soft.version命令安装软件
- yum方式安装(安装rpm包)：rpm 是linux的一种软件包名称，以.rmp结尾，安装的时候语法为：rpm -ivh。
rpm包的安装有个很大的缺点就是文件的关联性太大，有时装一个软件要安装很多其他的软件包，很麻烦。
所以为此RedHat小红帽开发了yum安装方法，他可以彻底解决这个关联性的问题，很方便，只要配置两个文件即可安装，安装方法是：yum -y install 。
yum并不是一中包，而是安装包的软件
简单的说： rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,
且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。
- bin文件安装：
  1. 打开一个终端，su -成root用户；
  2. chmod +x soft.bin
  3. ./soft.bin //运行这个命令就可以安装软件了
- 不需要安装的软件：有了些软件，比如lumaqq，是不需要安装的，自带jre解压缩后可直接运行。假设下载的是lumaqq.tar.gz，使用方法如下：
  1. 打开一个终端，su -成root用户；
  2. tar -xzvf lumaqq.tar.gz //这一步会生成一个叫LumaQQ的目录
  3. cd LumaQQ
  4. chmod +x lumaqq //设置lumaqq这个程序文件为可运行
  5. 此时就可以运行lumaqq了，用命令./lumaqq即可，但每次运行要输入全路径或切换到刚才生成的LumaQQ目录里
  6. 为了保证不设置路径就可以用，你可以在/bin目录下建立一个lumaqq的链接，用命令ln -s lumaqq /bin/ 即可，以后任何时候打开一个终端输入lumaqq就可以启动QQ聊天软件了
  7.  如果你要想lumaqq有个菜单项，使用菜单编辑工具，比如Alacarte Menu
Editor，找到上面生成的LumaQQ目录里的lumaqq设置一个菜单项就可以了，当然你
也可以直接到 /usr/share/applications目录，按照里面其它*.desktop文件的格
式生成一个自己的desktop文件即可。

### 用户和用户组管理
1. 用户管理简介：
   - 所有越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范
   - 在Linux中主要是通过用户配置文件来查看和修改用户信息
2. /etc/passwd
   - 第1字段：用户名称
   - 第2字段：密码标志/标识
   - 第3字段：UID（用户ID）
     - 0：超级用户
     - 1-499：系统用户（伪用户：不能登入，不能删除）
     - 500-2^32：普通用户
   - 第4字段：GID（用户[初始组](#初始组和附加组)ID）
   - 第5字段：用户说明
   - 第6字段：家目录
     - 超级用户：/root/
     - 普通用户：/home/用户名/
   - 第7字段：登陆之后的[Shell](#什么是shell)

3. /etc/shadow
   - 第1字段：用户名
   - 第2字段：加密密码
     - 加密算法为SHA512散列加密算法
     - 如果密码位是"!"或"*"代表没有密码，不能登入
   - 第3字段：密码最后一次修改日期
   - 第4字段：两次密码修改的间隔时间（和第3字段相比）
   - 第5字段：密码有效期（和第3字段相比）
   - 第6字段：密码修改到期钱的警告天数（和第5字段相比）
   - 第7字段：密码过期后的宽限天数（和第5字段比较）
     - 0：代表密码过期后立即消失
     - -1：代表密码永远不会失效
   - 第8字段：账户失效时间
   - 第9字段：保留

4. 常用命令
   - 添加用户信息：[useradd](#useradd)
   - 修改用户密码：[passwd](#passwd)
   - 修改用户信息：[usermod](#usermod)
   - 修改用户密码状态：[chage](#chage)
   - 删除用户：userdel [-r] 用户名
   - 切换用户：su [-/-c] 用户名字(只使用"-"代表连带用户的环境变量一起切换)
   - 添加用户组：groupadd [-g GID] 组名
   - 修改组：groupmod [-g GID/-n 新组名] 组名
   - 删除组: groupdel 组名

##### 初始组和附加组
- 初始组：用户一创建就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组
- 附加组：指用户可以加入多个其他的用户组，并拥有这个组的权限，附加组可以有多个
##### 什么是Shell
&ensp;&ensp;&ensp;&ensp;Shell就是Linux的命令解释器。在/etc/password当中，除了标准的Shell是/bin/bash之外，还可以写如/sbin/nologin来禁止普通用户登入
##### useradd
```shell script
[root@localhost ~]# useradd [选项] 用户名
-g：设置默认组
-d：设置默认家目录
-e：设置账户有效日期（yyyy-MM-dd）
例子：
~ useradd kk //添加用户kk
~ useradd -g root kk //添加用户kk，并指定用户所在的组为root用户组
~ useradd -r kk //创建一个系统用户kk
~ useradd-d /home/myf kk //新添加用户kk，其home目录为/home/myf
//当用户名kk登录主机时，系统进入的默认目录为/home/myf
```
##### passwd
```shell script
[root@localhost ~]# passwd [选项] 用户名
-d：删除密码
-f：强迫用户下次登录时必须修改口令
-w：口令要到期提前警告的天数
-k：更新只能发送在过期之后
-l：停止账号使用
-S：显示密码信息
-u：启用已被停止的账户
-x：指定口令最长存活期
-g：修改群组密码
指定口令最短存活期
-i：口令过期后多少天停用账户
例子：
~ passwd kk  //设置runoob用户的密码
Enter new UNIX password:  //输入新密码，输入的密码无回显
Retype new UNIX password:  //确认密码
passwd: password updated successfully

~ passwd -S kk  // 显示账号密码信息
runoob P 05/13/2010 0 99999 7 -1

~ passwd -d ll // 删除用户密码
passwd: password expiry information changed.
```
##### usermod
```shell script
[root@localhost ~]# usermod [选项] 用户名
-u UID：修改用户的UID号
-c 用户说明：修改用户的说明信息
-G 组名：修改用户的附加组
-L：临时锁定用户（Lock）
-U：解锁用户锁定（Unlock）
例子：
~ usermod -d /home/hnlinux kk  // 更改登录目录
~ usermod -u 777 kk  // 改变用户的uid
```
##### chage
```shell script
[root@localhost ~]# chage [选项] 用户名
-l：列出用户的详细密码状态
-d 日期：修改密码最后一次更改日期（shadow 3字段）
-m 天数：两次密码修改间隔（4字段）
-M 天数：密码有效期（5字段）
-W 天数：密码过期前警告天数（6字段）
-I 天数： 密码过后宽限天数（7字段）
-E 日期：账户失效时间（8字段）
例子：
~ chage -l kk   // 查看kk用户以及密码有效期
~ chage -M 60 -m 7 -W 7 kk  // 设置kk用户60天后密码过期，至少7天后才能修改密码，密码过期前7天开始收到告警信息。
~ chage -d 0 kk // 强制用户第一次登陆时修改密码
```
### 权限管理

1. ACL权限
&ensp;&ensp;当要给一个用户与文件属主、属组、其他人权限都不相同的时候使用，也就是说，这个用户对于这个文件不属于三种身份的任何一种，是属于第四种身份，那么我们就需要使用ACL权限去给他赋予单独的权限。
2. 文件特殊权限
   - SetUID/SetGID
     - 只有可以执行的二进制程序才能设定SUID权限
     - 命令执行者要对该程序拥有x（执行）权限
     - 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中变为文件的属主）
     - SetUID权限旨在该程序执行过程中有效，程序执行结束后失效
     - 关键目录应严格控制写权限。比如“/”，“/usr”等
     - 对系统中默认应该具有SetUID权限的文件做一列表，定时检查有没有这之外的文件被设置了SetUID权限
   - Sticky BIT
     - 粘着位目前只对目录有效
     - 普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限
     - 如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件，一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己简历的文件，但是不能删除其他用户简历的文件
3. 文件系统属性chattr权限： chattr [+-=] [选项] 文件/文件夹
   ```shell script
    [root@localhost ~]# chattr [+-=] [选项] 文件/文件夹
    选项
     i:如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据：如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件（包括root用户）
     a:如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中简历和修改文件，但不能删除
   ```

4. 系统命令sudo权限
   - sudo权限
     - root把本来只能超级用户执行的命令<b>赋予</b>普通用户执行
     - sudo的操作对象时系统命令
   - sudo使用
    ```shell script
    [root@localhost ~]# visudo
    # 实际修改的时/etc/sudoers文件

    root ALL=(ALL)   ALL
    # 用户名 被管理主机的地址=（可使用的身份）  授权命令（绝对路径）
    %wheel ALL=(ALL)   ALL
    # %组名 被管理主机的地址=（可使用的身份）  授权命令（绝对路径）
    # 被管理主机的地址如果是网段：代表如果我将整个网段的ip和服务名和密码都集中在一台服务器，那么配置网段后该用户可以访问这个网段下的所有主机执行授权命令
    ```

### 文件系统
1. 分区和文件系统
   - 分区类型
     - 主分区：总共最多分4个
     - 扩展分区：只能有七个，也算作主分区的一种，也就是说主分区加拓展分区最多有四个。但是拓展分区不能储存数据和格式化，必须再划分成逻辑分区才能使用
     - 逻辑分区：逻辑分区是再扩展分区中划分的，如果是IDE硬盘，Linux最多支持59个逻辑分区，如果是SCSI硬盘，Linux最多支持11个逻辑分区（设备名最小从sda5开始，前面4个给主分区和扩展分区使用）
![分区](./img/zone.png "分区")

        | 分区名字 |设备文件名 |
        |:-----:|:-----:|
        |主分区1|/dev/sda1|
        |主分区2|/dev/sda2|
        |主分区3|/dev/sda3|
        |扩展分区|/dev/sda4|
        |逻辑分区1|/dev/sda5|
        |逻辑分区2|/dev/sda6|

   - 文件系统
     - ext2：是ext文件系统的升级版，Red Hat Linux7.2版本以前的系统默认都是ext2文件系统，1993年发布，最大支持16TB的分区和最大2TB的文件
     - ext3：ext3文件系统是ext2文件系统的升级版本，最大的区别是自带日志功能，以再系统突然停止时提高文件系统的可靠性。最大支持16TB的分区和最大2TB的文件
     - ext4：ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是天翻地覆的，比如向下兼容ext3、最大1EB文件系统和16TB文件、无线数量子目录、Extents连续数据库概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。是CentOS6.3的默认文件系统

    - 文件读取

2. 文件系统的常用命令
   - df:显示目前在Linux系统上的文件系统的磁盘使用情况统计。df命令是从文件系统考虑的，不光要考虑文件占用的空间，还会统计被命令或程序占用的空间（最常见的就是文件已删除但是程序没有释放空间）
   - du：统计目录或文件大小，命令面向文件。
    ```shell script
    [root@localhost ~]# du [选项] [目录或文件名]
    -a 显示每个子文件的磁盘占用量。默许只统计子目录的磁盘占用量
    -h 使用习惯单位显示磁盘占用量，如KB、MB或GB等
    -s 统计总占用量，而不列出子目录和子文件的占用量
    ```
   - fsck：文件系统修复命令,系统开机执行，底层命令。
   - dumpe2fs：检测磁盘状态
   - mount：挂载Linux系统以外的文件
   - exec：在文件系统中执行可执行文件
   - mkdir：用于建立名称为 dirName 之子目录。
   - fdisk分区、挂载、格式化
  
3. 文件系统的一个使用流程：存储介质选择---》硬盘分区操作；创建分区来容纳文件系统；创建分区，这个分区可以是整个硬盘也可以是部分硬盘----》创建文件系统（我们在存储数据之前，你必须使用文件系统对其分区进行格式化）----》把它挂载到虚拟目录----》写入配置文件/etc/fstab

4. 硬盘分区的划分标准：硬盘分区由主分区、扩展分区和逻辑分区组成在一块硬盘上，如果是MBR分区方式，那么它的主分区最多只能有4个，或者3个主分区和1个扩展分区；在扩展分区上我们可以创建多个逻辑分区分区编号：主分区1-4 ，逻辑分区5.。。。。。LINUX规定：逻辑分区必须建立在扩展分区之上，而不是建立在主分区上

5. 分区作用：
   - 主分区：主要是用来启动操作系统的，它主要放的是操作系统的启动或引导程序，/boot分区最好放在主分区上
   - 扩展分区不能使用的，它只是做为逻辑分区的容器存在的；我们真正存放数据的是主分区和逻辑分区，大量数据都放在逻辑分区中
   - 如果你用的是GPT的分区方式，那么它没有限制主分区个数
   - 注意：从MBR转到GPT分区或者说从GPT转到MBR会导致数据全部丢失
   - 因此我们在对硬盘分区时最好划分主分区连续，比如说：主分区一、主分区二、扩展分区。

6. fdisk用法：
```shell script
[root@localhost ~]# fdisk [选项] <磁盘>    更改分区表
[root@localhost ~]# fdisk [选项] -l <磁盘> 列出分区表
[root@localhost ~]# fdisk -s <分区>        给出分区大小(块数)
选项：
 -b <大小>             扇区大小(512、1024、2048或4096)
 -c[=<模式>]           兼容模式：“dos”或“nondos”(默认)
 -h                    打印此帮助文本
 -u[=<单位>]           显示单位：“cylinders”(柱面)或“sectors”(扇区，默认)
 -v                    打印程序版本
 -C <数字>             指定柱面数
 -H <数字>             指定磁头数
 -S <数字>             指定每个磁道的扇区数
```
7. /etc/fstab
- 第1字段：分区设备文件名或UUID（硬盘通过唯一标识码）
- 第2字段：挂载点
- 第3字段：文件系统名称
- 第4字段：挂载参数
- 第5字段：指定分区是否被dump北方，0-不备份，1-每天备份，2-不定期备份
- 第6字段：指定分区是否被fsck检测，0-不检测。其他数字代表检测的优先级，例：1的优先级比2高

8. 分配swap分区
   - free命令：查看内存与swap分区使用情况
   - 新建swap分区：使用fdisk分区
   - 格式化：mkswap命令
   - 加入swap分区：swapon命令
   - swap分区开机自动挂载：编辑/etc/fstab文件
     - cached（缓存）：把读取出来的数据保存在内存当中，当每次读取时，不用读取硬盘而直接从内存当中读取，加速了数据的读取过程
     - buffer（缓冲）：写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度在集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程

### 服务管理
1. 服务的分类
![服务分类](./img/LinuxService.png)
   - 启动与自启动
     - 服务启动：就是在当前系统中让服务运行，并提供功能
     - 服务自启动：自启动是指让服务在系统开机或重启之后，随着系统的启动而自动启动服务
   - 查询已安装的服务
     - PRM包安装服的服务：
    ```shell script
    [root@localhost ~]# chlconfig --list
    # 查看服务自启动状态，可以看到所有RPM包安装的服务
    ```
     - 源码包安装的服务：查看服务安装位置
   - RPM安装服务和源码包安装服务的区别
     - 源码包安装在指定位置，一般是/usr/local/
     - RPM包安装在默认位置
       - /etc/init.d/：启动脚本位置
       - /etc/sysconfig/：初始化环境配置文件位置
       - /etc/：配置文件位置
       - /etc/xinetd.conf：xinetd配置文件
       - /etc/xinetd.d：基于xinetd服务的启动脚本
       - /var/lib/：服务产生的数据
       - /var/log/：日志
2. 独立服务管理
   - 独立的服务管理
     - 独立服务启动
       1. /etc/init.d/独立服务名 start|stop|status|restart
       2. service 独立服务名 start|stop|status|restart
     - 独立服务的自启动
       1. chkconfig [--level 运行级别] [独立服务名] [on|off]
       2. 修改 /etc/rc.d/rc.local文件
       3. 使用ntsysv命令管理自启动
   - 基于xinetd服务的管理:需要先安装xinetd服务先。基于xinetd服务的服务现在越来越少，了解一下就行。

3. 源码包服务管理
   - 源码包安装服务的启动
     - 使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法
   - 源码包服务的自启动：往/etc/rc.d/rc.local文件中加入源码包的启动方式
   - 让源码包服务被服务管理命令识别
     - 软连接：将启动脚本连接到/etc/init.d/目录下(ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache)
     - 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动
     ```shell script
     [root@localhost ~]# vi /etc/init.d/apache
     # chkconfig:35 86 76
     # 制定httpd脚本可以被chkconfig命令管理。格式是：chkconfig:运行级别 启动顺序 关闭顺序，启动顺序和关闭顺序不能和系统现有的服务冲突
     # 启动顺序和关闭顺序不能和系统现有的服务冲突
     # description: source package apache
     # 说明，内容随意
     ```

### 系统管理
1. 进程管理
   - 进程简介
     - 进程时正在执行的一个程序或者命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源
   - 进程管理的作用
     - 判断服务器健康状态
     - 查看系统中所有进程
     - 杀死进程
   - 查看系统中所有进程
     ```shell script
     [root@localhost ~]# ps aux
     # 查看系统中所有进程，使用BSD操作系统格式
     [root@localhost ~]# ps -le
     # 查看系统中所有进程，使用Linux标准命令格式
     ```
     |Name|作用|
     |:--|:---|
     |USER|该进程是由哪个用户产生的|
     |PID|进程的ID号|
     |%CPU|该进程占用CPU资源百分比|
     |%MEM|该进程占用物理内存的百分比|
     |VSZ|该进程占用虚拟内存的大小，单位时KB|
     |RSS|该进程占用实际物理内存的大小，单位是KB|
     |TTY|该进程时在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6时本地的字符界面终端,tty7时图形终端.pts/0-256代表虚拟终端|
     |STAT|进程状态。常见的状态有：R-运行、S-睡眠、T-终止状态、s-包含子进程、+-位于后台|
     |START|该进程的启动时间|
     |TIME|该进程占用CPU的运算时间|
     |COMMAND|产生此进程的命令名|
   - 查看系统健康状态
   ```shell script
   [root@localhost ~]# top [选项]
   选项
   -d 秒数： 指定top命令刷新间隔，默认时3秒
   ? 或 h：显示交互模式的帮助
   P：以CPU使用率排序（默认）
   M：以内存的使用率排序
   N：以PID排序
   q：退出top
   ```
   - 终止进程命令
   ```shell script
   [root@localhost ~]# kill -l
   # 查看可用的进程信号

   [root@localhost ~]# killall [选项][信号] 进程名
   # 按照进程名杀死进程
   选项
   -i：交互式，询问是否要杀死某个进程
   -I：忽略进程名大小写

   [root@localhost ~]# pkill [信号][信号] 进程名
   # 按照进程名终止进程
   选项
   -t 终端号：按照终端号提出用户
   ```
   |信号代号(常用)|信号名称|说明|
   |:--|:--|:--|
   |1|SIGHUP|该信号让进程立即关闭，然后重新读取配置文件之后重启|
   |2|SIGINT|程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键|
   |8|SIGFPE|在发生致命的算术运算错误时发生，不仅包括浮点运算错误，还包括溢出及除数为0等其他所有的算数错误|
   |9|SIGKILL|用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程|
   |14|SIGALRM|时钟定时信号，计算的时实际的时间或时钟时间。alarm函数使用该信号|
   |15|SIGTERM|正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号时无法正常终止进程的，我们才会尝试SIGKILL信号|
   |18|SIGCONT|该信号可以让暂停的进程恢复执行，本信号不会被阻断|
   |19|SIGSTOP|该信号可以暂停前台进程，相当于输入ctrl+z。本信号不能被阻断|

2. 工作管理
   - 将程序放入后台执行:命令最后加上"&"
   - 查看后台的工作：jobs -l
   - 将后台暂停的工作恢复到前台执行：fg 工作号
   - 将后台暂停的工作恢复到后台执行：bg 工作号

3. 系统资源查看
   - 监控系统资源：vmstat [刷新延时， 刷新次数]
   - 开机时内核检查信息：dmesg
   - 查看内存使用状态：free
   - 启动时间和平均负载：uptime
   - 查看系统与内核相关信息：uname
   - 判断当前系统位数：file /bin/ls
   - 查看当前Linux系统的发行版本：lsb_release -a
   - 列出进程打开或使用的文件信息：lsof [选项]

4. 系统定时任务
   - crond服务管理与访问控制
   ```shell script 
   [root@localhost ~]# service crond start
   [root@localhost ~]# chkconfig crond on
   ```
   - 用户的crontab设置
   ```shell script
   [root@localhost ~]# crontab [选项]
   选项:
   -e：编辑crontab定时任务
   -l：查询crontab任务
   -r：删除当前用户所有的crontab任务
   # 进入crontab编辑界面，会打开vim编辑你的工作
   * * * * * command 
   ```
     - 第1个*：分钟
     - 第2个*：小时
     - 第3个*：天
     - 第4个*：月
     - 第5个*：星期几

   |时间|含义|
   |:--|:--|
   |45 22 * * * command|在22点45分执行命令|
   |0 17 * * 1 command|每周一的17点0分执行命令|
   |0 5 1,15 * * command|每月1号和15号的凌晨5点0分执行命令|
   |*/10 4 * * * command|每天凌晨4点，每隔10分钟执行一次命令|
   |0 5 * * 1-6 command|周一到周六每天凌晨5点0分执行命令|


### 日志管理
1. 日志管理简介
   - 在CentOS 6.x中日志服务已经又rsyslogd取代了原先的syslogd服务。rsyslogd日志服务更加先进，功能更多。但是不论该服务的使用，还是日志文件的格式其实都是和syslogd服务相兼容的，所以学习起来基本和 syslogd服务一致。  
   rsyslogd的新特点：
      - 基于TCP网络协议传输日志信息
      - 更安全的网络传输方式
      - 有日志消息的及时分析框架
      - 后台数据库
      - 配置文件中可以写简单的逻辑判断
      - 与syslogd配置文件相兼容
   - 常见日志的作用：
      |日志文件|说明|
      |:--|:--|
      |/var/log/cron|记录了系统定时任务相关的日志|
      |/var/log/cups/|记录打印信息的日志|
      |/var/log/dmesg|记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内行人自检信息|
      |/var/log/btmp|记录错误登记的日志。这个日志是二进制文件，不能直接vi查看。|
      |/var/log/lastlog|记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件|
      |/var/log/mailog|记录邮件信息|
      |/var/log/message|记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件|
      |/var/log/secure|记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中|
      |/var/log/wtmp|永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机时间。同样这个文件也是一个二进制文件|
      |/var/log/utmp|记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi查看|

   - 除了系统默认的日志外，采用RPM方式安装的系统服务也会默认把日志记录在/var/log/目录中，不过这些日志不是有rsyslogd服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身日志

2. rsyslogd日志服务
   - 日志文件格式：基础日志格式包裹以下四列
     - 事件产生的时间
     - 发生事件的服务器的主机名
     - 产生事件的服务名和程序名
     - 事件的具体信息
   - /etc/rsyslog.com配置文件 
      - 配置：
      ```
      authpriv.*                /var/log/secure
      # 服务名称[连接符号] 日志等级  日志记录位置
      # 认证相关服务，所有日志等级    记录在/var/log/secure日志中
      ```
      - 服务名称说明：
      |服务名称|说明|
      |:--|:--|
      |auth|安全和认证相关消息|
      |authpriv|安全和认证相关消息|
      |cron|系统定时任务cront和at产生的日志|
      |daemon|和各个守护进程相关的日志|
      |ftp|ftp守护进程产生的日志|
      |kern|内核产生的日志|
      |local0-local7|为本地使用预留的服务|
      |lpr|打印产生的日志|

      - 连接符：
        - “*”代表所有日志等级
        - “.”代表只要比后面的等级高（包含），日志都会记录下来
        - “.=”代表只记录所需等级的日志
        - “.!”代表不等于

      -  日志等级：debug、info、notice、warning、err、crit、alert、emerg
      -  日志记录位置
        - 日志文件的绝对路径，如“/var/log/secure”
        - 系统设备文件，如“/dev/lp0
        - 转发给远程主机，如“@192.168.0.1:514”
        - 用户名，如“root”
        - 忽略或丢弃日志，如“～”

3. 日志轮替
   - 日志文件的命名规则
      - 如果配置文件中拥有“dateext”参数，那么日志会用日期来做日志文件的后缀，例如“secure-20200807”。这样日志文件不会重叠，所以也就不需要日志文件改名，只需要保存制定的日志个数，删除多余的日志文件即可
      - 如果配置文件中没有“dateext”参数，那么日志文件就需要改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志。
   - logrotate配置文件
      |参数|说明|
      |:--|:--|
      |daily|日志轮替周期是每天|
      |weekly|日志轮替周期是每周|
      |monthly|日志轮替周期是每月|
      |rotate 数字|保留的日志文件个数|
      |compress|日志轮替时，旧的日志进行压缩|
      |create mode owner group|建立新日志，同时制定新日志的权限与所有制和所属组|
      |mail address|输出内容通过邮件发送到制定地址|
      |missingok|如果日志不存在，则忽略该日志的警告信息|
      |notifempty|如果日志为空维纳，则不进行日志轮替|
      |minsize 大小|日志轮替的最小值。|
      |size 大小|日志只有大于指定大小才进行日志轮替|
      |dateext|使用日期作为日志轮替文件的后缀|

   - 把apache日志加入轮替
      ```shell script
      [root@localhost ~]# vi /etc/logrotate.conf
      /usr/local/apache2/logs/access_log {
        daily
        create
        rotate 30
      }
      ```
   - logrotate命令
      ```shell script
      [root@localhost ~]# logrotate [选项] 配置文件名
      选项：
      如果次命令没有选项，会按照配置文件中的条件进行日志轮替
      -v：显示日志轮替过程
      -f：强制进行日志轮替，
      ```

### 启动管理
#### CentOS 6.x启动管理
1. 系统运行级别

|运行级别|含义|
|:--|:--|
|0|关机|
|1|单用户模式，可以想象为Windows的安全模式，主要用于系统修复|
|2|不完全的命令行模式，不含NFS服务|
|3|完全的命令行模式，就是标准的字符界面|
|4|系统保留|
|5|图形模式|
|6|重启动|

##### 运行级别命令
```shell script
[root@localhost ~]# init 运行级别
# 改变运行级别命令
[root@localhost ~]# runlevel
# 查看运行级别命令
```
2. 系统启动过程

![系统启动流程](./img/sysstart.png)

##### initramfs内存文件系统
  - CentOS 6.x中使用initramfs内存文件系统取代了CentOS 5.x中的initrd RAM Disk。他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的内存模型，比如USB、SATA、SCSI硬盘的驱动和LVM、RAID文件系统的驱动
  ```shell script
  # 手动模拟initramfs解压建立仿真根目录
  [root@localhost ~]# mkdir /tmp/initramfs
  # 建立测试目录
  [root@localhost ~]# cp /boot/initramfs-2.6.xxx.img /tmp/initramfs
  [root@localhost ~]# cd /tmp/initramfs
  [root@localhost ~]# file initramfs-2.6.xxx.img
  # 得到时gzip格式的文件
  [root@localhost ~]# mv initramfs-2.6.xxx.img initramfs-2.6.xxx.img.gz
  # 加上后缀
  [root@localhost ~]# gunzip initramfs-2.6.xxx.img.gz
  # 解压
  [root@localhost ~]# file initramfs-2.6.xxx.img.gz
  # 查看解压后的文件格式,得到cpio格式的文件
  [root@localhost ~]# cpio -ivcdu initramfs-2.6.xxx.img.gz
  # 使用cpio解压
  ```
##### 调用/etc/init/rcS.conf配置文件
  - 先调用/etc/rc.d/rc.sysinit,然后由/etc/rc.d/rc.sysinit配置文件进行Linux系统初始化
  - 然后再调用/etc/inittab，然后由/etc/inittab配置文件确定系统的默认运行级别
##### 调用/etc/rc.d/rc文件
  - 运行级别参数传入/etc/rc.d/rc这个脚本之后，由这个脚本文件按照不同的运行级别启动/etc/rc[0,6].d/目录中的相应的程序
  - /etc/rc3.d/k??开头的文件(??是数字)，会按照数字顺序一次关闭
  - /etc/rc3.d/S??开头的文件(??是数字)，会按照数字顺序一次启动

#### 启动引导程序grub
1. Grub配置文件
   - grub中分区表示

    |硬盘|分区|Linux中设备文件名|Grub中设备文件名|
    |:--|:--|:--|:--|
    |第一块SCSI硬盘|第一个主分区|/dev/sda1|hd(0,0)|
    |第一块SCSI硬盘|第二个主分区|/dev/sda2|hd(0,1)|
    |第一块SCSI硬盘|扩展分区|/dev/sda3|hd(0,2)|
    |第一块SCSI硬盘|第一个逻辑分区|/dev/sda5|hd(0,4)|
    |第二块SCSI硬盘|第一个主分区|/dev/sdb1|hd(1,0)|
    |第二块SCSI硬盘|第二个主分区|/dev/sdb2|hd(1,1)|
    |第二块SCSI硬盘|扩展分区|/dev/sdb3|hd(1,2)|
    |第二块SCSI硬盘|第一个逻辑分区|/dev/sdb5|hd(1,4)|

   - grub配置文件

   ```shell script
    [root@localhost ~]# vi /boot/grub/grub.conf
    default=0 
    # 默认启动第一个系统
    timeout=5
    # 等待时间，默认是5秒
    splashimage=(hd0,0)/grub/splash.xpm.gz
    # 这里是指定grub启动时的背景图像文件的保存位置
    hiddenmenu
    # 隐藏菜单
   ```
2. Grub加密与字符界面分辨率调整
   - grub加密
   ```shell script
   [root@localhost ~]# grub-md5-crypt
   # 生成加密码串，然后将密码串加入到grub配置文件中
   ```
   - 纯字符界面分辨率调整
   ```shell script 
   [root@localhost ~]# grep "CONFIG_FRAMEBUFFER_CONSOLE" /boot/config-2.6.xxxx.el6.i686
   # 检查内核是否支持分辨率修改
   # 修改grub配置文件 kernel ..... vga=分辨率
   ```
#### 系统修复模式
1. 单用户模式
   - 遗忘root密码
   - 修改系统默认运行级别
2. 光盘修复模式
   - 重要系统文件丢失，导致系统无法启动
   - grub密码遗忘
   - BIOS加密




### 备份与恢复
1. 概述：防止发生不可抗因素导致Linux服务器物理节点损毁导致文件的丢失或损坏，进而导致业务的停止，需要将数据信息备份起来，以备不时之需。
   - Linux系统中需要备份的数据
     - /root/
     - /home/
     - /var/spool/mail/
     - /etc/
     - 其他目录
   - 安装服务的数据
2. 备份策略
   - 完全备份：完全备份就是指把所有需要备份的数据全部备份，当然完全备份可以备份整块硬盘，这个分区或某个具体的目录
   - 增量备份：第一次备份使用完全备份，之后的备份都是备份新增数据（上一次备份到现在的新增数据），每次备份都和上一次备份比较
   - 差异备份：第一次备份使用完全备份，第二次备份使用增量备份，第三次备份备份第二次到第三次的所有数据，第四次备份备份第二次到第四次的所有数据...每次备份都和第一次备份比较
3. 常用命令：
   - dump命令
    ```shell script 
    [root@localhost ~]# dump [选项] 备份之后的文件名 原文件或目录
    选项：
    -level：0-9十个备份级别
    -f 文件名：指定备份之后的文件名
    -u：备份成功之后，把备份时间记录再/etc/dumpdates文件
    -v：显示备份过程中更多的输出信息
    -j：调用bzlib库压缩备份文件，将备份文件压缩成.bz2格式
    -w：显示允许被dump的分区和备份等级及备份时间
    例子：
    [root@localhost ~]# dump -0uj -f /root/boot.bak.bz2 /boot/
    # 执行一次完全备份，压缩备份/boot/目录，更新备份时间
    [root@localhost ~]# cat /etc/dumpdates
    # 查看备份时间文件
    [root@localhost ~]# cp install.log /boot/
    # 复制日志文件到/boot分区
    [root@localhost ~]# dump -1uj -f /root/boot.bak1.bz2 /boot
    # 增量备份到/boot分区。并压缩
    [root@localhost ~]# dump -W
    # 查询分区的备份时间及备份级别等
    ```
    - restore命令
    ```shell script
    [root@localhost ~]# restore [模式选项] [选项]
    选项模式：restore名称常用的模式有以下四种，这四个模式不能混用
    -C：比较备份数据和实际数据的变化
    -i：进入交互模式，手工选择需要恢复的文件
    -t：查看模式，用于查看备份文件中拥有那些数据
    -r：还原模式，用于数据还原
    选项：
    -f：指定备份文件的文件名
    例子：
    # 还原boot.bak.bz2分区备份
    [root@localhost ~]# mkdir boot.test
    [root@localhost ~]# cd boot.test/
    [root@localhost ~]# restore -r -f /root/boot.bak.bz2
    # 先还原完全备份的数据
    [root@localhost ~]# restore -r -f /root/boot.bak1.bz2
    # 恢复增量备份的数据
    ```


## Linux核心理解
- [同步机制](#同步机制)
   1. [自旋锁](#1-自旋锁)
   2. [原子操作](#2-原子操作)
   3. [信号量](#3-信号量)
   4. [读写信号量](#4-读写信号量)
   5. [大内核锁](#5-大内核锁)
   6. [读写锁](#6-读写锁)
   7. [大读者锁](#7-大读者锁)
   8. [RCU](#8-RCU)
   9. [顺序锁](#9-顺序锁)
   10. [各种同步机制的比较](#10-各种同步机制的比较)
- [用户态和内核态](#用户态和内核态)
- [文件系统](#文件系统)
- [进程管理](#进程管理)
- [内存管理](#内存管理)
- [网络系统](#网络系统)
- [线程/进程/进程间通信]

### 同步机制
在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。在主流的Linux内核中包含了几乎所有现代的操作系统具有的同步机制，这些同步机制包括：原子操作、信号量（semaphore）、读写信号量（rw_semaphore）、spinlock、BKL（Big Kernel Lock）、rwlock、brlock（只包含在2.4内核中）、RCU（只包含在2.6内核中）和seqlock（只包含在2.6内核中）
1. 自旋锁  
&ensp;&ensp;自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一致循环在哪里看是否该自旋锁的保持者已经释放了锁，“自旋”一次因此而得名。由于自旋锁使用者一般保持锁时间非常短，因此选择自旋锁而不是互斥锁是非常必要的，自旋锁的效率远高于互斥锁。  
&ensp;&ensp;信号量和读写信号量适合于保持时间较长的清空，他们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。  
&ensp;&ensp;自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在讷河可抢占或SMP的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。  
&ensp;&ensp;跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在哪里，知道该自旋锁的保持者释放了锁。  
&ensp;&ensp;无论时互斥锁，还是自旋锁。在任何市可，最多只能有一个保持者，在任何时刻最多只能有一个执行单元获得锁。
   - 自旋锁是不可递归的，以为自选锁内部关了抢占，递归的话最深层级的函数调用尝试获取自旋锁但是由于第一层级函数调用还没释放，所以会一直死自旋下去。
   - 线程获取自旋锁之前，要禁止当前处理器上的中断。（事实上，spin_lock() 函数内部会自己做这个）。
2. 原子操作  
&ensp;&ensp;所谓原子操作，就是操作绝对不会再执行完毕前被任何其他任务或事件打断，也就是说，他是最小的执行单位，不可能有比它更小的执行单位。原子操作主要用于实现资源计数，很多引用计数（refcnt）就是通过原子操作实现的
3. 信号量（Semaphore）  
&ensp;&ensp;Linux内核的信号量在概念和原理上与用户态的System V的IPC机制信号量是一样的，但是它绝不可能在内核之外使用，因此它与System V的IPC机制信号量毫不相干。  
&ensp;&ensp;信号量在创建时需要设置一个初始值，表事同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有一个任务可以范文信号量保护的共享资源。一个任务要访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值减1，若当前信号量的值为负数，表明无法获得信号量，因而可以立刻访问被信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非整数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。
   - 线程获取不到信号量的时候，不会像自旋锁一样循环区试图获取锁，而是进入睡眠，直至有信号量释放出来时，才会唤醒睡眠的线程，进入临界区执行。
  
4. 读写信号量（rw_semaphore）  
&ensp;&ensp;读写信号量对访问者进行了细分，或者为读者，或者为写者。读者在保持读写信号量期间只能对该读写信号量保护的共享资源进行读访问，如果一个任务除了需要读，可能还需要写，呢么它必须被归类为写者，它在对共享资源访问之前必须先获得写者身份，写者在发现自己不需要写访问的情况下可能降级为读者。读写信号量同时拥有的读者数不受限制，也就是说可以有任意多个读者同时拥有一个读写信号量。如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则，读者必须被挂起知道写者释放该信号量。如果一个读写信号量当前没有被读者或写者拥有并且也没有写者等待该信号量，那么一个写者可以成功获得该读写信号量，否则写者被挂起，知道没有任何访问者。因此，写者是排他性的，独占性的。
&ensp;&ensp;读写信号量有两种实现，一种是通用的，不依赖与硬件架构，因此，增加新的架构不需要重新实现它，但缺点是性能低，获得和释放读写信号量的开销大；另一种是架构相关的，因此性能高，获取和释放读写信号量的开销小，但增加新的架构需要重新实现。在内核配置时，可以通过选项去控制使用哪一种实现  
   - 读锁之间共享，即一个线程获取读锁后，其他线程也可以以读的方式获取锁
   - 写锁之间是互斥的，即一个县城持有了写锁之后，其他线程不能以读或者写的方式持有这个锁。
   - 读写锁之间是互斥的，即一个县城持有了读锁之后，其他线程不能以写的方式持有这个锁。
  
5. 大内核锁（BKL——Big Kernel Lock）  
&ensp;&ensp;大内核锁本质上也是自旋锁，但是它又不同于自旋锁，自旋锁是不可以递归获取锁的，因为那样会导致死锁。但大内核锁可以递归获取锁。大内核锁用于保护整个内核么人自旋锁用于保护非常特定的某一共享资源。进程保持大内核锁时可以发生调度，具体实现时：在执行schedule时，schedule将检查进程是否拥有大内核锁，如果有，它将被释放，以至于其他的进程能过获得该锁，而当轮到该进程时，再让它重新获得大内核锁。注意再保持自旋期间是不运行发生调度的。  
&ensp;&ensp;整个内核只有一个大内核锁，内核只有一个，而大内核锁是保护整个内核的。  
&ensp;&ensp;大内核锁是历史遗留，内核中用的非常少，一般保持该锁额时间较长，因此不提倡使用。从2.6.11内核起，大内核锁可以通过配置内核使其变得可抢占（自旋锁是不可抢占的），这时它实质上是一个互斥锁，使用信号量实现。
6. 读写锁（rwlock）  
&ensp;&ensp;读写锁是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只能对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相当于自旋锁而言，能提高并发性，因为再多处理器系统中，它允许同时有多个读者来访问恭喜昂资源，最大可能的读者数为实际的逻辑cpu数。写者是排他性的，一个读写锁同时只能有一个写者或者多个读者，但不能同时既有读者又有写者。  
&ensp;&ensp;在读写锁保持期间是抢占失效的。  
&ensp;&ensp;如果读写锁当前没有读者，也没有写者，那么写者可以立刻获取读写锁，否则它必须自旋在哪里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。
7. 大读者锁（brlock-Big Reader Lock）  
&ensp;&ensp;大读者锁是读写锁的高性能版，读者可以非常快地获得锁，但写者获得锁的开销比较大。大读者锁只存在于2.4内核中，在2.6中已经没有这种锁（提醒读者特别注意）。它们的使用与读写锁的使用类似，只是所有的大读者锁都是事先已经定义好的。这种锁适合于读多写少的情况，它在这种情况下远好于读写锁。  
&ensp;&ensp;大读者锁的实现机制是：每一个大读者锁在所有CPU上都有一个本地读者写者锁，一个读者仅需要获得本地CPU的读者锁，而写者必须获得所有CPU上的锁。
8. RCU（Read-Copy Update）  
&ensp;&ensp;RCU(Read-Copy Update)，顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。  
&ensp;&ensp;RCU也是读写锁的高性能版本，但是它比大读者锁具有更好的扩展性和性能。 RCU既允许多个读者同时访问被保护的数据，又允许多个读者和多个写者同时访问被保护的数据（注意：是否可以有多个写者并行访问取决于写者之间使用的同步机制），读者没有任何同步开销，而写者的同步开销则取决于使用的写者间同步机制。但RCU不能替代读写锁，因为如果写比较多时，对读者的性能提高不能弥补写者导致的损失。
9. 顺序锁（seqlock）  
&ensp;&ensp;顺序锁也是对读写锁的一种优化，对于顺序锁，读者绝不会被写者阻塞，也就说，读者可以在写者对被顺序锁保护的共享资源进行写操作时仍然可以继续读，而不必等待写者完成写操作，写者也不需要等待所有读者完成读操作才去进行写操作。但是，写者与写者之间仍然是互斥的，即如果有写者在进行写操作，其他写者必须自旋在那里，直到写者释放了顺序锁。  
&ensp;&ensp;这种锁有一个限制，它必须要求被保护的共享资源不含有指针，因为写者可能使得指针失效，但读者如果正要访问该指针，将导致OOPs。  
&ensp;&ensp;如果读者在读操作期间，写者已经发生了写操作，那么，读者必须重新读取数据，以便确保得到的数据是完整的。  
&ensp;&ensp;这种锁对于读写同时进行的概率比较小的情况，性能是非常好的，而且它允许读写同时进行，因而更大地提高了并发性
10. 各种同步机制的比较

|类型|机制|应用场合|
|:--|:--|:--|
|自旋锁|使用忙等方法，进程不挂起|(1)用于多处理器间共享数据 <br> (2)在可抢占的内核线程里共享数据 <br> (3)自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用，比如终中断上下文|
|信号量|阻塞式等待，进程刮起|(1)适合于共享区保持时间较长的情况 <br> (2)只能用于进程上下文|
|原子操作|数据的原子访问|(1)共享简单的数据类型：整形，比特型 <br> (2)适合高效率的场合|
|读写锁|特殊的自旋锁|(1)允许同时读共享资源，但只能有一个写 <br> (2)读优先于写，读写不能同时|
|顺序锁|一种免锁机制，基于反问计数|(1)允许同时读共享资源，但只能有一个写 <br> (2)写优先于读，读写不能同时|
|RCU|通过副本的免锁访问|(1)对读占主要的场合提供高新能 <br> (2)读访问不必获取锁，不必执行原子操作或禁止中断|
|关闭中断|通过禁止终端的手段，排除单处理器上的并发，会导致终端延迟|(1)中断与正常进程共享数据 <br> (2)多个中断共享数据 <br> (3)临界区一般很短|

![LockChoose](./img/lockchoose.png)

### 用户态和内核态
1. 简介  
从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，内核态相当于一个介于硬件与应用之间的层，内核有ring 0的权限，拥有直接调用硬件资源的权限。 用户态的应用程序可以通过三种方式访问内核态资源：
   - 系统调用  
   系统调用时操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口，例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移。
   - 库函数
   库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现。它对系统调用进行封装，提供简单的基本接口给用户，这样增强了程序的灵活性，当然对于简单的接口，也可以直接使用系统调用访问资源，例如：open（），write（），read（）等等。库函数根据不同的标准也有不同的版本，例如：glibc库，posix库等。
   - Shell脚本
   shell顾名思义，就是外壳的意思。就好像把内核包裹起来的外壳。它是一种特殊的应用程序，俗称命令行。为了方便用户和系统交互，一般一个shell对应一个终端，呈现给用户交互窗口。当然shell也是编程的，它有标准的shell语法，符合其语法的文本叫shell脚本。很多人都会用shell脚本实现一些常用的功能，可以提高工作效率。

![Unix System Strucure](./img/UnixSysMode.png "Unix System Strucure")

2. 状态转换
   - 系统调用：因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。  
   ![StateSwitch](./img/stateSwitch.png "State Switch")

   - 异常：当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。
   - 外围设备的终端：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。
   - 注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。

3. 用户态到内核态具体的切换步骤
linux下每个进程的栈有两个，一个是用户态栈，一个是内核态栈。在需要从用户态栈切换到内核的时候，需要进行执行栈的转换，保存用户态的状态，包括寄存器状态，然后执行内核态操作，操作完成后要恢复现场，切换到用户态。

### 进程管理
1. 进程与线程：进程是资源分配的基本单位，进程是独立调度的基本单位，一个进程可以拥有多个线程，他们共享进程资源。
    - 资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源
    - 调度：线程是独立调度的基本单位，统一进程中，线程的切换不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程是，会引起进程切换
    - 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
    - 通信：线程间可以直接读写同一进程中的数据进行通信，但是进程间通信需要借助IPC

2. 进程状态的切换

![进程状态的切换](./img/ProcessStateWwitch.png "进程状态的切换")

    - 就绪态（ready）：等待被调度
    - 运行态（running）
    - 阻塞态（waiting）：等待资源  
注意：  
- 只有就绪态和运行态可以互相切换，其他的都是单项转换。就绪态的进程通过调度算法从而获得CPU时间，转为运行态；而运行态的进程，在分配给它的CPU时间片用完之后就会转为就绪态，等待下一次调度
- 阻塞态是缺少需要的资源从而由运行态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态

3. 进程调度算法
    - 批处理系统
       - 先来先服务 first-come first-serverd(FCFS)：非抢占式的调度算法，按照请求的顺序进行调度。  
       有利于长作业，但不利于短作业，因为短作业必须一致等待前面的长作业执行完毕才能执行，而长作业又需要执行很长的时间，造成了短作业等待的时间过长
       - 短作业优先 shortest job first(SJF)：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。  
       长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
       - 最短剩余时间优先 shortest remaining time next(SRTN)：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
    - 交互式系统
       - 时间片轮转：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
          - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
          - 而如果时间片过长，那么实时性就不能得到保证。
       - 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
       - 多级反馈队列  
       一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。  
      多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。  
      每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。  
      可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。
      ![多级反馈队列](./img/MultistageFeedbackQueue.png "多级反馈队列")
      
    - 实时系统：实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。
4. 进程同步

   |同步方式|临界区(Critical Section)|互斥量(Mutex)|信号量(Semaphore)|事件(Event)|
   |:--:|:--|:--|:--|:--|
   |解释|通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问|为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。|为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数|用来通知线程有一些事件已发生，从而启动后继任务的开始。|
   |优点|保证在某一市可只有一个线程能访问数据的简便方法|使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享（跨进程同步）|适用于对Socket（套接字）程序中线程的同步（跨进程同步）。（例：网络上的HTTP服务器对同一时间访问的同一页面的用户数加以限制吗，只有不大于设定的最大用户数目的线程能够进行访问。而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。）|事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作（跨进程同步）|
   |缺点|虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可以用来同步多个进程中的线程|互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部使用的话，使用临界区会带来速度上的优势并能够减少资源占用。|1.信号量机制必须有公共内存，不能用于分布式操作系统<br>2.信号量机制共呢个强大，但使用时对信号量量的操作分散，而且难以控制，读写和维护都很困难，加重了程序员的编码负担<br>3.核心操作P-V分散在各用户程序的代码中，不易控制和管理。||

5. 经典同步问题
    - 生存者-消费者问题：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。  
    因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。  
    为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。  
    注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。
    - 哲学家进餐问题：五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。  
    如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。  
    为了防止死锁的发生，可以设置两个条件：
       - 必须同时拿起左右两根筷子；
       - 只有在两个邻居都没有进餐的情况下才允许进餐。
    - 读者-写者问题(TODO)：允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。  

6. 进程通信  
   进程同步与进程通信很容易混淆，它们的区别在于：
      - 进程同步：控制多个进程按一定顺序执行；
      - 进程通信：进程间传输信息。

   进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。
   
    - 管道：
    - 命名管道（FIFO）：
    - 消息队列：
    - 信号量：
    - 共享存储：
    - 套接字：


### 内存系统

### 网络管理